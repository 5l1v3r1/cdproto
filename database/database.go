// Package database provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome Database domain.
//
// Generated by the chromedp-gen command.
package database

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

// EnableParams enables database tracking, database events will now be
// delivered to the client.
type EnableParams struct{}

// Enable enables database tracking, database events will now be delivered to
// the client.
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes Database.enable.
func (p *EnableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandDatabaseEnable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// DisableParams disables database tracking, prevents database events from
// being sent to the client.
type DisableParams struct{}

// Disable disables database tracking, prevents database events from being
// sent to the client.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes Database.disable.
func (p *DisableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandDatabaseDisable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type GetDatabaseTableNamesParams struct {
	DatabaseID DatabaseID `json:"databaseId"`
}

// parameters:
//   databaseId
func GetDatabaseTableNames(databaseId DatabaseID) *GetDatabaseTableNamesParams {
	return &GetDatabaseTableNamesParams{
		DatabaseID: databaseId,
	}
}

// GetDatabaseTableNamesReturns return values.
type GetDatabaseTableNamesReturns struct {
	TableNames []string `json:"tableNames,omitempty"`
}

// Do executes Database.getDatabaseTableNames.
//
// returns:
//   tableNames
func (p *GetDatabaseTableNamesParams) Do(ctxt context.Context, h FrameHandler) (tableNames []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandDatabaseGetDatabaseTableNames, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetDatabaseTableNamesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.TableNames, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

type ExecuteSQLParams struct {
	DatabaseID DatabaseID `json:"databaseId"`
	Query      string     `json:"query"`
}

// parameters:
//   databaseId
//   query
func ExecuteSQL(databaseId DatabaseID, query string) *ExecuteSQLParams {
	return &ExecuteSQLParams{
		DatabaseID: databaseId,
		Query:      query,
	}
}

// ExecuteSQLReturns return values.
type ExecuteSQLReturns struct {
	ColumnNames []string              `json:"columnNames,omitempty"`
	Values      []easyjson.RawMessage `json:"values,omitempty"`
	SQLError    *Error                `json:"sqlError,omitempty"`
}

// Do executes Database.executeSQL.
//
// returns:
//   columnNames
//   values
//   sqlError
func (p *ExecuteSQLParams) Do(ctxt context.Context, h FrameHandler) (columnNames []string, values []easyjson.RawMessage, sqlError *Error, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, nil, nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandDatabaseExecuteSQL, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, nil, nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r ExecuteSQLReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, nil, nil, ErrInvalidResult
			}

			return r.ColumnNames, r.Values, r.SQLError, nil

		case error:
			return nil, nil, nil, v
		}

	case <-ctxt.Done():
		return nil, nil, nil, ErrContextDone
	}

	return nil, nil, nil, ErrUnknownResult
}
