// Package tracing provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome Tracing domain.
//
// Generated by the chromedp-gen command.
package tracing

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

// StartParams start trace events collection.
type StartParams struct {
	BufferUsageReportingInterval float64      `json:"bufferUsageReportingInterval,omitempty"` // If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
	TransferMode                 TransferMode `json:"transferMode,omitempty"`                 // Whether to report trace events as series of dataCollected events or to save trace to a stream (defaults to ReportEvents).
	TraceConfig                  *TraceConfig `json:"traceConfig,omitempty"`
}

// Start start trace events collection.
//
// parameters:
func Start() *StartParams {
	return &StartParams{}
}

// WithBufferUsageReportingInterval if set, the agent will issue bufferUsage
// events at this interval, specified in milliseconds.
func (p StartParams) WithBufferUsageReportingInterval(bufferUsageReportingInterval float64) *StartParams {
	p.BufferUsageReportingInterval = bufferUsageReportingInterval
	return &p
}

// WithTransferMode whether to report trace events as series of dataCollected
// events or to save trace to a stream (defaults to ReportEvents).
func (p StartParams) WithTransferMode(transferMode TransferMode) *StartParams {
	p.TransferMode = transferMode
	return &p
}

// WithTraceConfig [no description].
func (p StartParams) WithTraceConfig(traceConfig *TraceConfig) *StartParams {
	p.TraceConfig = traceConfig
	return &p
}

// Do executes Tracing.start.
func (p *StartParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTracingStart, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// EndParams stop trace events collection.
type EndParams struct{}

// End stop trace events collection.
func End() *EndParams {
	return &EndParams{}
}

// Do executes Tracing.end.
func (p *EndParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTracingEnd, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// GetCategoriesParams gets supported tracing categories.
type GetCategoriesParams struct{}

// GetCategories gets supported tracing categories.
func GetCategories() *GetCategoriesParams {
	return &GetCategoriesParams{}
}

// GetCategoriesReturns return values.
type GetCategoriesReturns struct {
	Categories []string `json:"categories,omitempty"` // A list of supported tracing categories.
}

// Do executes Tracing.getCategories.
//
// returns:
//   categories - A list of supported tracing categories.
func (p *GetCategoriesParams) Do(ctxt context.Context, h cdp.FrameHandler) (categories []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTracingGetCategories, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetCategoriesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Categories, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// RequestMemoryDumpParams request a global memory dump.
type RequestMemoryDumpParams struct{}

// RequestMemoryDump request a global memory dump.
func RequestMemoryDump() *RequestMemoryDumpParams {
	return &RequestMemoryDumpParams{}
}

// RequestMemoryDumpReturns return values.
type RequestMemoryDumpReturns struct {
	DumpGUID string `json:"dumpGuid,omitempty"` // GUID of the resulting global memory dump.
	Success  bool   `json:"success,omitempty"`  // True iff the global memory dump succeeded.
}

// Do executes Tracing.requestMemoryDump.
//
// returns:
//   dumpGUID - GUID of the resulting global memory dump.
//   success - True iff the global memory dump succeeded.
func (p *RequestMemoryDumpParams) Do(ctxt context.Context, h cdp.FrameHandler) (dumpGUID string, success bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTracingRequestMemoryDump, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestMemoryDumpReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", false, cdp.ErrInvalidResult
			}

			return r.DumpGUID, r.Success, nil

		case error:
			return "", false, v
		}

	case <-ctxt.Done():
		return "", false, cdp.ErrContextDone
	}

	return "", false, cdp.ErrUnknownResult
}

// RecordClockSyncMarkerParams record a clock sync marker in the trace.
type RecordClockSyncMarkerParams struct {
	SyncID string `json:"syncId"` // The ID of this clock sync marker
}

// RecordClockSyncMarker record a clock sync marker in the trace.
//
// parameters:
//   syncID - The ID of this clock sync marker
func RecordClockSyncMarker(syncID string) *RecordClockSyncMarkerParams {
	return &RecordClockSyncMarkerParams{
		SyncID: syncID,
	}
}

// Do executes Tracing.recordClockSyncMarker.
func (p *RecordClockSyncMarkerParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTracingRecordClockSyncMarker, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}
