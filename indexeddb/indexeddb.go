// Package indexeddb provides the Chrome Debugging Protocol
// commands, types, and events for the IndexedDB domain.
//
// Generated by the chromedp-gen command.
package indexeddb

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

// EnableParams enables events from backend.
type EnableParams struct{}

// Enable enables events from backend.
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes IndexedDB.enable against the provided context and
// target handler.
func (p *EnableParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandIndexedDBEnable, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// DisableParams disables events from backend.
type DisableParams struct{}

// Disable disables events from backend.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes IndexedDB.disable against the provided context and
// target handler.
func (p *DisableParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandIndexedDBDisable, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// RequestDatabaseNamesParams requests database names for given security
// origin.
type RequestDatabaseNamesParams struct {
	SecurityOrigin string `json:"securityOrigin"` // Security origin.
}

// RequestDatabaseNames requests database names for given security origin.
//
// parameters:
//   securityOrigin - Security origin.
func RequestDatabaseNames(securityOrigin string) *RequestDatabaseNamesParams {
	return &RequestDatabaseNamesParams{
		SecurityOrigin: securityOrigin,
	}
}

// RequestDatabaseNamesReturns return values.
type RequestDatabaseNamesReturns struct {
	DatabaseNames []string `json:"databaseNames,omitempty"` // Database names for origin.
}

// Do executes IndexedDB.requestDatabaseNames against the provided context and
// target handler.
//
// returns:
//   databaseNames - Database names for origin.
func (p *RequestDatabaseNamesParams) Do(ctxt context.Context, h cdp.Handler) (databaseNames []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandIndexedDBRequestDatabaseNames, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestDatabaseNamesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.DatabaseNames, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}

// RequestDatabaseParams requests database with given name in given frame.
type RequestDatabaseParams struct {
	SecurityOrigin string `json:"securityOrigin"` // Security origin.
	DatabaseName   string `json:"databaseName"`   // Database name.
}

// RequestDatabase requests database with given name in given frame.
//
// parameters:
//   securityOrigin - Security origin.
//   databaseName - Database name.
func RequestDatabase(securityOrigin string, databaseName string) *RequestDatabaseParams {
	return &RequestDatabaseParams{
		SecurityOrigin: securityOrigin,
		DatabaseName:   databaseName,
	}
}

// RequestDatabaseReturns return values.
type RequestDatabaseReturns struct {
	DatabaseWithObjectStores *DatabaseWithObjectStores `json:"databaseWithObjectStores,omitempty"` // Database with an array of object stores.
}

// Do executes IndexedDB.requestDatabase against the provided context and
// target handler.
//
// returns:
//   databaseWithObjectStores - Database with an array of object stores.
func (p *RequestDatabaseParams) Do(ctxt context.Context, h cdp.Handler) (databaseWithObjectStores *DatabaseWithObjectStores, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandIndexedDBRequestDatabase, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestDatabaseReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.DatabaseWithObjectStores, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}

// RequestDataParams requests data from object store or index.
type RequestDataParams struct {
	SecurityOrigin  string    `json:"securityOrigin"`     // Security origin.
	DatabaseName    string    `json:"databaseName"`       // Database name.
	ObjectStoreName string    `json:"objectStoreName"`    // Object store name.
	IndexName       string    `json:"indexName"`          // Index name, empty string for object store data requests.
	SkipCount       int64     `json:"skipCount"`          // Number of records to skip.
	PageSize        int64     `json:"pageSize"`           // Number of records to fetch.
	KeyRange        *KeyRange `json:"keyRange,omitempty"` // Key range.
}

// RequestData requests data from object store or index.
//
// parameters:
//   securityOrigin - Security origin.
//   databaseName - Database name.
//   objectStoreName - Object store name.
//   indexName - Index name, empty string for object store data requests.
//   skipCount - Number of records to skip.
//   pageSize - Number of records to fetch.
func RequestData(securityOrigin string, databaseName string, objectStoreName string, indexName string, skipCount int64, pageSize int64) *RequestDataParams {
	return &RequestDataParams{
		SecurityOrigin:  securityOrigin,
		DatabaseName:    databaseName,
		ObjectStoreName: objectStoreName,
		IndexName:       indexName,
		SkipCount:       skipCount,
		PageSize:        pageSize,
	}
}

// WithKeyRange key range.
func (p RequestDataParams) WithKeyRange(keyRange *KeyRange) *RequestDataParams {
	p.KeyRange = keyRange
	return &p
}

// RequestDataReturns return values.
type RequestDataReturns struct {
	ObjectStoreDataEntries []*DataEntry `json:"objectStoreDataEntries,omitempty"` // Array of object store data entries.
	HasMore                bool         `json:"hasMore,omitempty"`                // If true, there are more entries to fetch in the given range.
}

// Do executes IndexedDB.requestData against the provided context and
// target handler.
//
// returns:
//   objectStoreDataEntries - Array of object store data entries.
//   hasMore - If true, there are more entries to fetch in the given range.
func (p *RequestDataParams) Do(ctxt context.Context, h cdp.Handler) (objectStoreDataEntries []*DataEntry, hasMore bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, false, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandIndexedDBRequestData, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestDataReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, false, cdp.ErrInvalidResult
			}

			return r.ObjectStoreDataEntries, r.HasMore, nil

		case error:
			return nil, false, v
		}

	case <-ctxt.Done():
		return nil, false, ctxt.Err()
	}

	return nil, false, cdp.ErrUnknownResult
}

// ClearObjectStoreParams clears all entries from an object store.
type ClearObjectStoreParams struct {
	SecurityOrigin  string `json:"securityOrigin"`  // Security origin.
	DatabaseName    string `json:"databaseName"`    // Database name.
	ObjectStoreName string `json:"objectStoreName"` // Object store name.
}

// ClearObjectStore clears all entries from an object store.
//
// parameters:
//   securityOrigin - Security origin.
//   databaseName - Database name.
//   objectStoreName - Object store name.
func ClearObjectStore(securityOrigin string, databaseName string, objectStoreName string) *ClearObjectStoreParams {
	return &ClearObjectStoreParams{
		SecurityOrigin:  securityOrigin,
		DatabaseName:    databaseName,
		ObjectStoreName: objectStoreName,
	}
}

// Do executes IndexedDB.clearObjectStore against the provided context and
// target handler.
func (p *ClearObjectStoreParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandIndexedDBClearObjectStore, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// DeleteDatabaseParams deletes a database.
type DeleteDatabaseParams struct {
	SecurityOrigin string `json:"securityOrigin"` // Security origin.
	DatabaseName   string `json:"databaseName"`   // Database name.
}

// DeleteDatabase deletes a database.
//
// parameters:
//   securityOrigin - Security origin.
//   databaseName - Database name.
func DeleteDatabase(securityOrigin string, databaseName string) *DeleteDatabaseParams {
	return &DeleteDatabaseParams{
		SecurityOrigin: securityOrigin,
		DatabaseName:   databaseName,
	}
}

// Do executes IndexedDB.deleteDatabase against the provided context and
// target handler.
func (p *DeleteDatabaseParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandIndexedDBDeleteDatabase, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}
