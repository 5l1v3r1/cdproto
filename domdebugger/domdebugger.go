// Package domdebugger provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome DOMDebugger domain.
//
// DOM debugging allows setting breakpoints on particular DOM operations and
// events. JavaScript execution will stop on these operations as if there was a
// regular breakpoint set.
//
// Generated by the chromedp-gen command.
package domdebugger

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/knq/chromedp/cdp/runtime"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

// SetDOMBreakpointParams sets breakpoint on particular operation with DOM.
type SetDOMBreakpointParams struct {
	NodeID NodeID            `json:"nodeId"` // Identifier of the node to set breakpoint on.
	Type   DOMBreakpointType `json:"type"`   // Type of the operation to stop upon.
}

// SetDOMBreakpoint sets breakpoint on particular operation with DOM.
//
// parameters:
//   nodeId - Identifier of the node to set breakpoint on.
//   type - Type of the operation to stop upon.
func SetDOMBreakpoint(nodeId NodeID, type_ DOMBreakpointType) *SetDOMBreakpointParams {
	return &SetDOMBreakpointParams{
		NodeID: nodeId,
		Type:   type_,
	}
}

// Do executes DOMDebugger.setDOMBreakpoint.
func (p *SetDOMBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerSetDOMBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// RemoveDOMBreakpointParams removes DOM breakpoint that was set using
// setDOMBreakpoint.
type RemoveDOMBreakpointParams struct {
	NodeID NodeID            `json:"nodeId"` // Identifier of the node to remove breakpoint from.
	Type   DOMBreakpointType `json:"type"`   // Type of the breakpoint to remove.
}

// RemoveDOMBreakpoint removes DOM breakpoint that was set using
// setDOMBreakpoint.
//
// parameters:
//   nodeId - Identifier of the node to remove breakpoint from.
//   type - Type of the breakpoint to remove.
func RemoveDOMBreakpoint(nodeId NodeID, type_ DOMBreakpointType) *RemoveDOMBreakpointParams {
	return &RemoveDOMBreakpointParams{
		NodeID: nodeId,
		Type:   type_,
	}
}

// Do executes DOMDebugger.removeDOMBreakpoint.
func (p *RemoveDOMBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerRemoveDOMBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// SetEventListenerBreakpointParams sets breakpoint on particular DOM event.
type SetEventListenerBreakpointParams struct {
	EventName  string `json:"eventName"`            // DOM Event name to stop on (any DOM event will do).
	TargetName string `json:"targetName,omitempty"` // EventTarget interface name to stop on. If equal to "*" or not provided, will stop on any EventTarget.
}

// SetEventListenerBreakpoint sets breakpoint on particular DOM event.
//
// parameters:
//   eventName - DOM Event name to stop on (any DOM event will do).
func SetEventListenerBreakpoint(eventName string) *SetEventListenerBreakpointParams {
	return &SetEventListenerBreakpointParams{
		EventName: eventName,
	}
}

// WithTargetName eventTarget interface name to stop on. If equal to "*" or
// not provided, will stop on any EventTarget.
func (p SetEventListenerBreakpointParams) WithTargetName(targetName string) *SetEventListenerBreakpointParams {
	p.TargetName = targetName
	return &p
}

// Do executes DOMDebugger.setEventListenerBreakpoint.
func (p *SetEventListenerBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerSetEventListenerBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// RemoveEventListenerBreakpointParams removes breakpoint on particular DOM
// event.
type RemoveEventListenerBreakpointParams struct {
	EventName  string `json:"eventName"`            // Event name.
	TargetName string `json:"targetName,omitempty"` // EventTarget interface name.
}

// RemoveEventListenerBreakpoint removes breakpoint on particular DOM event.
//
// parameters:
//   eventName - Event name.
func RemoveEventListenerBreakpoint(eventName string) *RemoveEventListenerBreakpointParams {
	return &RemoveEventListenerBreakpointParams{
		EventName: eventName,
	}
}

// WithTargetName eventTarget interface name.
func (p RemoveEventListenerBreakpointParams) WithTargetName(targetName string) *RemoveEventListenerBreakpointParams {
	p.TargetName = targetName
	return &p
}

// Do executes DOMDebugger.removeEventListenerBreakpoint.
func (p *RemoveEventListenerBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerRemoveEventListenerBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// SetInstrumentationBreakpointParams sets breakpoint on particular native
// event.
type SetInstrumentationBreakpointParams struct {
	EventName string `json:"eventName"` // Instrumentation name to stop on.
}

// SetInstrumentationBreakpoint sets breakpoint on particular native event.
//
// parameters:
//   eventName - Instrumentation name to stop on.
func SetInstrumentationBreakpoint(eventName string) *SetInstrumentationBreakpointParams {
	return &SetInstrumentationBreakpointParams{
		EventName: eventName,
	}
}

// Do executes DOMDebugger.setInstrumentationBreakpoint.
func (p *SetInstrumentationBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerSetInstrumentationBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// RemoveInstrumentationBreakpointParams removes breakpoint on particular
// native event.
type RemoveInstrumentationBreakpointParams struct {
	EventName string `json:"eventName"` // Instrumentation name to stop on.
}

// RemoveInstrumentationBreakpoint removes breakpoint on particular native
// event.
//
// parameters:
//   eventName - Instrumentation name to stop on.
func RemoveInstrumentationBreakpoint(eventName string) *RemoveInstrumentationBreakpointParams {
	return &RemoveInstrumentationBreakpointParams{
		EventName: eventName,
	}
}

// Do executes DOMDebugger.removeInstrumentationBreakpoint.
func (p *RemoveInstrumentationBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerRemoveInstrumentationBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// SetXHRBreakpointParams sets breakpoint on XMLHttpRequest.
type SetXHRBreakpointParams struct {
	URL string `json:"url"` // Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
}

// SetXHRBreakpoint sets breakpoint on XMLHttpRequest.
//
// parameters:
//   url - Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
func SetXHRBreakpoint(url string) *SetXHRBreakpointParams {
	return &SetXHRBreakpointParams{
		URL: url,
	}
}

// Do executes DOMDebugger.setXHRBreakpoint.
func (p *SetXHRBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerSetXHRBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// RemoveXHRBreakpointParams removes breakpoint from XMLHttpRequest.
type RemoveXHRBreakpointParams struct {
	URL string `json:"url"` // Resource URL substring.
}

// RemoveXHRBreakpoint removes breakpoint from XMLHttpRequest.
//
// parameters:
//   url - Resource URL substring.
func RemoveXHRBreakpoint(url string) *RemoveXHRBreakpointParams {
	return &RemoveXHRBreakpointParams{
		URL: url,
	}
}

// Do executes DOMDebugger.removeXHRBreakpoint.
func (p *RemoveXHRBreakpointParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerRemoveXHRBreakpoint, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// GetEventListenersParams returns event listeners of the given object.
type GetEventListenersParams struct {
	ObjectID runtime.RemoteObjectID `json:"objectId"` // Identifier of the object to return listeners for.
}

// GetEventListeners returns event listeners of the given object.
//
// parameters:
//   objectId - Identifier of the object to return listeners for.
func GetEventListeners(objectId runtime.RemoteObjectID) *GetEventListenersParams {
	return &GetEventListenersParams{
		ObjectID: objectId,
	}
}

// GetEventListenersReturns return values.
type GetEventListenersReturns struct {
	Listeners []*EventListener `json:"listeners,omitempty"` // Array of relevant listeners.
}

// Do executes DOMDebugger.getEventListeners.
//
// returns:
//   listeners - Array of relevant listeners.
func (p *GetEventListenersParams) Do(ctxt context.Context, h FrameHandler) (listeners []*EventListener, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMDebuggerGetEventListeners, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetEventListenersReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Listeners, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}
