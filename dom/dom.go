// Package dom provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome DOM domain.
//
// This domain exposes DOM read/write operations. Each DOM Node is
// represented with its mirror object that has an id. This id can be used to get
// additional information on the Node, resolve it into the JavaScript object
// wrapper, etc. It is important that client receives DOM events only for the
// nodes that are known to the client. Backend keeps track of the nodes that
// were sent to the client and never sends the same node twice. It is client's
// responsibility to collect information about the nodes that were sent to the
// client.<p>Note that iframe owner elements will return corresponding document
// elements as their child nodes.</p>.
//
// Generated by the chromedp-gen command.
package dom

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/knq/chromedp/cdp/runtime"
	"github.com/mailru/easyjson"
)

// EnableParams enables DOM agent for the given page.
type EnableParams struct{}

// Enable enables DOM agent for the given page.
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes DOM.enable.
func (p *EnableParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMEnable, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// DisableParams disables DOM agent for the given page.
type DisableParams struct{}

// Disable disables DOM agent for the given page.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes DOM.disable.
func (p *DisableParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMDisable, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// GetDocumentParams returns the root DOM node (and optionally the subtree)
// to the caller.
type GetDocumentParams struct {
	Depth  int64 `json:"depth,omitempty"`  // The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
	Pierce bool  `json:"pierce,omitempty"` // Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
}

// GetDocument returns the root DOM node (and optionally the subtree) to the
// caller.
//
// parameters:
func GetDocument() *GetDocumentParams {
	return &GetDocumentParams{}
}

// WithDepth the maximum depth at which children should be retrieved,
// defaults to 1. Use -1 for the entire subtree or provide an integer larger
// than 0.
func (p GetDocumentParams) WithDepth(depth int64) *GetDocumentParams {
	p.Depth = depth
	return &p
}

// WithPierce whether or not iframes and shadow roots should be traversed
// when returning the subtree (default is false).
func (p GetDocumentParams) WithPierce(pierce bool) *GetDocumentParams {
	p.Pierce = pierce
	return &p
}

// GetDocumentReturns return values.
type GetDocumentReturns struct {
	Root *cdp.Node `json:"root,omitempty"` // Resulting node.
}

// Do executes DOM.getDocument.
//
// returns:
//   root - Resulting node.
func (p *GetDocumentParams) Do(ctxt context.Context, h cdp.FrameHandler) (root *cdp.Node, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetDocument, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetDocumentReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Root, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// GetFlattenedDocumentParams returns the root DOM node (and optionally the
// subtree) to the caller.
type GetFlattenedDocumentParams struct {
	Depth  int64 `json:"depth,omitempty"`  // The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
	Pierce bool  `json:"pierce,omitempty"` // Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).
}

// GetFlattenedDocument returns the root DOM node (and optionally the
// subtree) to the caller.
//
// parameters:
func GetFlattenedDocument() *GetFlattenedDocumentParams {
	return &GetFlattenedDocumentParams{}
}

// WithDepth the maximum depth at which children should be retrieved,
// defaults to 1. Use -1 for the entire subtree or provide an integer larger
// than 0.
func (p GetFlattenedDocumentParams) WithDepth(depth int64) *GetFlattenedDocumentParams {
	p.Depth = depth
	return &p
}

// WithPierce whether or not iframes and shadow roots should be traversed
// when returning the subtree (default is false).
func (p GetFlattenedDocumentParams) WithPierce(pierce bool) *GetFlattenedDocumentParams {
	p.Pierce = pierce
	return &p
}

// GetFlattenedDocumentReturns return values.
type GetFlattenedDocumentReturns struct {
	Nodes []*cdp.Node `json:"nodes,omitempty"` // Resulting node.
}

// Do executes DOM.getFlattenedDocument.
//
// returns:
//   nodes - Resulting node.
func (p *GetFlattenedDocumentParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodes []*cdp.Node, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetFlattenedDocument, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetFlattenedDocumentReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Nodes, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// CollectClassNamesFromSubtreeParams collects class names for the node with
// given id and all of it's child nodes.
type CollectClassNamesFromSubtreeParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to collect class names.
}

// CollectClassNamesFromSubtree collects class names for the node with given
// id and all of it's child nodes.
//
// parameters:
//   nodeID - Id of the node to collect class names.
func CollectClassNamesFromSubtree(nodeID cdp.NodeID) *CollectClassNamesFromSubtreeParams {
	return &CollectClassNamesFromSubtreeParams{
		NodeID: nodeID,
	}
}

// CollectClassNamesFromSubtreeReturns return values.
type CollectClassNamesFromSubtreeReturns struct {
	ClassNames []string `json:"classNames,omitempty"` // Class name list.
}

// Do executes DOM.collectClassNamesFromSubtree.
//
// returns:
//   classNames - Class name list.
func (p *CollectClassNamesFromSubtreeParams) Do(ctxt context.Context, h cdp.FrameHandler) (classNames []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMCollectClassNamesFromSubtree, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CollectClassNamesFromSubtreeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.ClassNames, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// RequestChildNodesParams requests that children of the node with given id
// are returned to the caller in form of setChildNodes events where not only
// immediate children are retrieved, but all children down to the specified
// depth.
type RequestChildNodesParams struct {
	NodeID cdp.NodeID `json:"nodeId"`           // Id of the node to get children for.
	Depth  int64      `json:"depth,omitempty"`  // The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
	Pierce bool       `json:"pierce,omitempty"` // Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).
}

// RequestChildNodes requests that children of the node with given id are
// returned to the caller in form of setChildNodes events where not only
// immediate children are retrieved, but all children down to the specified
// depth.
//
// parameters:
//   nodeID - Id of the node to get children for.
func RequestChildNodes(nodeID cdp.NodeID) *RequestChildNodesParams {
	return &RequestChildNodesParams{
		NodeID: nodeID,
	}
}

// WithDepth the maximum depth at which children should be retrieved,
// defaults to 1. Use -1 for the entire subtree or provide an integer larger
// than 0.
func (p RequestChildNodesParams) WithDepth(depth int64) *RequestChildNodesParams {
	p.Depth = depth
	return &p
}

// WithPierce whether or not iframes and shadow roots should be traversed
// when returning the sub-tree (default is false).
func (p RequestChildNodesParams) WithPierce(pierce bool) *RequestChildNodesParams {
	p.Pierce = pierce
	return &p
}

// Do executes DOM.requestChildNodes.
func (p *RequestChildNodesParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMRequestChildNodes, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// QuerySelectorParams executes querySelector on a given node.
type QuerySelectorParams struct {
	NodeID   cdp.NodeID `json:"nodeId"`   // Id of the node to query upon.
	Selector string     `json:"selector"` // Selector string.
}

// QuerySelector executes querySelector on a given node.
//
// parameters:
//   nodeID - Id of the node to query upon.
//   selector - Selector string.
func QuerySelector(nodeID cdp.NodeID, selector string) *QuerySelectorParams {
	return &QuerySelectorParams{
		NodeID:   nodeID,
		Selector: selector,
	}
}

// QuerySelectorReturns return values.
type QuerySelectorReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // Query selector result.
}

// Do executes DOM.querySelector.
//
// returns:
//   nodeID - Query selector result.
func (p *QuerySelectorParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMQuerySelector, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r QuerySelectorReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// QuerySelectorAllParams executes querySelectorAll on a given node.
type QuerySelectorAllParams struct {
	NodeID   cdp.NodeID `json:"nodeId"`   // Id of the node to query upon.
	Selector string     `json:"selector"` // Selector string.
}

// QuerySelectorAll executes querySelectorAll on a given node.
//
// parameters:
//   nodeID - Id of the node to query upon.
//   selector - Selector string.
func QuerySelectorAll(nodeID cdp.NodeID, selector string) *QuerySelectorAllParams {
	return &QuerySelectorAllParams{
		NodeID:   nodeID,
		Selector: selector,
	}
}

// QuerySelectorAllReturns return values.
type QuerySelectorAllReturns struct {
	NodeIds []cdp.NodeID `json:"nodeIds,omitempty"` // Query selector result.
}

// Do executes DOM.querySelectorAll.
//
// returns:
//   nodeIds - Query selector result.
func (p *QuerySelectorAllParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeIds []cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMQuerySelectorAll, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r QuerySelectorAllReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.NodeIds, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// SetNodeNameParams sets node name for a node with given id.
type SetNodeNameParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to set name for.
	Name   string     `json:"name"`   // New node's name.
}

// SetNodeName sets node name for a node with given id.
//
// parameters:
//   nodeID - Id of the node to set name for.
//   name - New node's name.
func SetNodeName(nodeID cdp.NodeID, name string) *SetNodeNameParams {
	return &SetNodeNameParams{
		NodeID: nodeID,
		Name:   name,
	}
}

// SetNodeNameReturns return values.
type SetNodeNameReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // New node's id.
}

// Do executes DOM.setNodeName.
//
// returns:
//   nodeID - New node's id.
func (p *SetNodeNameParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetNodeName, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SetNodeNameReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// SetNodeValueParams sets node value for a node with given id.
type SetNodeValueParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to set value for.
	Value  string     `json:"value"`  // New node's value.
}

// SetNodeValue sets node value for a node with given id.
//
// parameters:
//   nodeID - Id of the node to set value for.
//   value - New node's value.
func SetNodeValue(nodeID cdp.NodeID, value string) *SetNodeValueParams {
	return &SetNodeValueParams{
		NodeID: nodeID,
		Value:  value,
	}
}

// Do executes DOM.setNodeValue.
func (p *SetNodeValueParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetNodeValue, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// RemoveNodeParams removes node with given id.
type RemoveNodeParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to remove.
}

// RemoveNode removes node with given id.
//
// parameters:
//   nodeID - Id of the node to remove.
func RemoveNode(nodeID cdp.NodeID) *RemoveNodeParams {
	return &RemoveNodeParams{
		NodeID: nodeID,
	}
}

// Do executes DOM.removeNode.
func (p *RemoveNodeParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMRemoveNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// SetAttributeValueParams sets attribute for an element with given id.
type SetAttributeValueParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the element to set attribute for.
	Name   string     `json:"name"`   // Attribute name.
	Value  string     `json:"value"`  // Attribute value.
}

// SetAttributeValue sets attribute for an element with given id.
//
// parameters:
//   nodeID - Id of the element to set attribute for.
//   name - Attribute name.
//   value - Attribute value.
func SetAttributeValue(nodeID cdp.NodeID, name string, value string) *SetAttributeValueParams {
	return &SetAttributeValueParams{
		NodeID: nodeID,
		Name:   name,
		Value:  value,
	}
}

// Do executes DOM.setAttributeValue.
func (p *SetAttributeValueParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetAttributeValue, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// SetAttributesAsTextParams sets attributes on element with given id. This
// method is useful when user edits some existing attribute value and types in
// several attribute name/value pairs.
type SetAttributesAsTextParams struct {
	NodeID cdp.NodeID `json:"nodeId"`         // Id of the element to set attributes for.
	Text   string     `json:"text"`           // Text with a number of attributes. Will parse this text using HTML parser.
	Name   string     `json:"name,omitempty"` // Attribute name to replace with new attributes derived from text in case text parsed successfully.
}

// SetAttributesAsText sets attributes on element with given id. This method
// is useful when user edits some existing attribute value and types in several
// attribute name/value pairs.
//
// parameters:
//   nodeID - Id of the element to set attributes for.
//   text - Text with a number of attributes. Will parse this text using HTML parser.
func SetAttributesAsText(nodeID cdp.NodeID, text string) *SetAttributesAsTextParams {
	return &SetAttributesAsTextParams{
		NodeID: nodeID,
		Text:   text,
	}
}

// WithName attribute name to replace with new attributes derived from text
// in case text parsed successfully.
func (p SetAttributesAsTextParams) WithName(name string) *SetAttributesAsTextParams {
	p.Name = name
	return &p
}

// Do executes DOM.setAttributesAsText.
func (p *SetAttributesAsTextParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetAttributesAsText, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// RemoveAttributeParams removes attribute with given name from an element
// with given id.
type RemoveAttributeParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the element to remove attribute from.
	Name   string     `json:"name"`   // Name of the attribute to remove.
}

// RemoveAttribute removes attribute with given name from an element with
// given id.
//
// parameters:
//   nodeID - Id of the element to remove attribute from.
//   name - Name of the attribute to remove.
func RemoveAttribute(nodeID cdp.NodeID, name string) *RemoveAttributeParams {
	return &RemoveAttributeParams{
		NodeID: nodeID,
		Name:   name,
	}
}

// Do executes DOM.removeAttribute.
func (p *RemoveAttributeParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMRemoveAttribute, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// GetOuterHTMLParams returns node's HTML markup.
type GetOuterHTMLParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to get markup for.
}

// GetOuterHTML returns node's HTML markup.
//
// parameters:
//   nodeID - Id of the node to get markup for.
func GetOuterHTML(nodeID cdp.NodeID) *GetOuterHTMLParams {
	return &GetOuterHTMLParams{
		NodeID: nodeID,
	}
}

// GetOuterHTMLReturns return values.
type GetOuterHTMLReturns struct {
	OuterHTML string `json:"outerHTML,omitempty"` // Outer HTML markup.
}

// Do executes DOM.getOuterHTML.
//
// returns:
//   outerHTML - Outer HTML markup.
func (p *GetOuterHTMLParams) Do(ctxt context.Context, h cdp.FrameHandler) (outerHTML string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetOuterHTML, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetOuterHTMLReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", cdp.ErrInvalidResult
			}

			return r.OuterHTML, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", cdp.ErrContextDone
	}

	return "", cdp.ErrUnknownResult
}

// SetOuterHTMLParams sets node HTML markup, returns new node id.
type SetOuterHTMLParams struct {
	NodeID    cdp.NodeID `json:"nodeId"`    // Id of the node to set markup for.
	OuterHTML string     `json:"outerHTML"` // Outer HTML markup to set.
}

// SetOuterHTML sets node HTML markup, returns new node id.
//
// parameters:
//   nodeID - Id of the node to set markup for.
//   outerHTML - Outer HTML markup to set.
func SetOuterHTML(nodeID cdp.NodeID, outerHTML string) *SetOuterHTMLParams {
	return &SetOuterHTMLParams{
		NodeID:    nodeID,
		OuterHTML: outerHTML,
	}
}

// Do executes DOM.setOuterHTML.
func (p *SetOuterHTMLParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetOuterHTML, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// PerformSearchParams searches for a given string in the DOM tree. Use
// getSearchResults to access search results or cancelSearch to end this search
// session.
type PerformSearchParams struct {
	Query                     string `json:"query"`                               // Plain text or query selector or XPath search query.
	IncludeUserAgentShadowDOM bool   `json:"includeUserAgentShadowDOM,omitempty"` // True to search in user agent shadow DOM.
}

// PerformSearch searches for a given string in the DOM tree. Use
// getSearchResults to access search results or cancelSearch to end this search
// session.
//
// parameters:
//   query - Plain text or query selector or XPath search query.
func PerformSearch(query string) *PerformSearchParams {
	return &PerformSearchParams{
		Query: query,
	}
}

// WithIncludeUserAgentShadowDOM true to search in user agent shadow DOM.
func (p PerformSearchParams) WithIncludeUserAgentShadowDOM(includeUserAgentShadowDOM bool) *PerformSearchParams {
	p.IncludeUserAgentShadowDOM = includeUserAgentShadowDOM
	return &p
}

// PerformSearchReturns return values.
type PerformSearchReturns struct {
	SearchID    string `json:"searchId,omitempty"`    // Unique search session identifier.
	ResultCount int64  `json:"resultCount,omitempty"` // Number of search results.
}

// Do executes DOM.performSearch.
//
// returns:
//   searchID - Unique search session identifier.
//   resultCount - Number of search results.
func (p *PerformSearchParams) Do(ctxt context.Context, h cdp.FrameHandler) (searchID string, resultCount int64, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMPerformSearch, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r PerformSearchReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", 0, cdp.ErrInvalidResult
			}

			return r.SearchID, r.ResultCount, nil

		case error:
			return "", 0, v
		}

	case <-ctxt.Done():
		return "", 0, cdp.ErrContextDone
	}

	return "", 0, cdp.ErrUnknownResult
}

// GetSearchResultsParams returns search results from given fromIndex to
// given toIndex from the sarch with the given identifier.
type GetSearchResultsParams struct {
	SearchID  string `json:"searchId"`  // Unique search session identifier.
	FromIndex int64  `json:"fromIndex"` // Start index of the search result to be returned.
	ToIndex   int64  `json:"toIndex"`   // End index of the search result to be returned.
}

// GetSearchResults returns search results from given fromIndex to given
// toIndex from the sarch with the given identifier.
//
// parameters:
//   searchID - Unique search session identifier.
//   fromIndex - Start index of the search result to be returned.
//   toIndex - End index of the search result to be returned.
func GetSearchResults(searchID string, fromIndex int64, toIndex int64) *GetSearchResultsParams {
	return &GetSearchResultsParams{
		SearchID:  searchID,
		FromIndex: fromIndex,
		ToIndex:   toIndex,
	}
}

// GetSearchResultsReturns return values.
type GetSearchResultsReturns struct {
	NodeIds []cdp.NodeID `json:"nodeIds,omitempty"` // Ids of the search result nodes.
}

// Do executes DOM.getSearchResults.
//
// returns:
//   nodeIds - Ids of the search result nodes.
func (p *GetSearchResultsParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeIds []cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetSearchResults, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetSearchResultsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.NodeIds, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// DiscardSearchResultsParams discards search results from the session with
// the given id. getSearchResults should no longer be called for that search.
type DiscardSearchResultsParams struct {
	SearchID string `json:"searchId"` // Unique search session identifier.
}

// DiscardSearchResults discards search results from the session with the
// given id. getSearchResults should no longer be called for that search.
//
// parameters:
//   searchID - Unique search session identifier.
func DiscardSearchResults(searchID string) *DiscardSearchResultsParams {
	return &DiscardSearchResultsParams{
		SearchID: searchID,
	}
}

// Do executes DOM.discardSearchResults.
func (p *DiscardSearchResultsParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMDiscardSearchResults, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// RequestNodeParams requests that the node is sent to the caller given the
// JavaScript node object reference. All nodes that form the path from the node
// to the root are also sent to the client as a series of setChildNodes
// notifications.
type RequestNodeParams struct {
	ObjectID runtime.RemoteObjectID `json:"objectId"` // JavaScript object id to convert into node.
}

// RequestNode requests that the node is sent to the caller given the
// JavaScript node object reference. All nodes that form the path from the node
// to the root are also sent to the client as a series of setChildNodes
// notifications.
//
// parameters:
//   objectID - JavaScript object id to convert into node.
func RequestNode(objectID runtime.RemoteObjectID) *RequestNodeParams {
	return &RequestNodeParams{
		ObjectID: objectID,
	}
}

// RequestNodeReturns return values.
type RequestNodeReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // Node id for given object.
}

// Do executes DOM.requestNode.
//
// returns:
//   nodeID - Node id for given object.
func (p *RequestNodeParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMRequestNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestNodeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// SetInspectModeParams enters the 'inspect' mode. In this mode, elements
// that user is hovering over are highlighted. Backend then generates
// 'inspectNodeRequested' event upon element selection.
type SetInspectModeParams struct {
	Mode            InspectMode      `json:"mode"`                      // Set an inspection mode.
	HighlightConfig *HighlightConfig `json:"highlightConfig,omitempty"` // A descriptor for the highlight appearance of hovered-over nodes. May be omitted if enabled == false.
}

// SetInspectMode enters the 'inspect' mode. In this mode, elements that user
// is hovering over are highlighted. Backend then generates
// 'inspectNodeRequested' event upon element selection.
//
// parameters:
//   mode - Set an inspection mode.
func SetInspectMode(mode InspectMode) *SetInspectModeParams {
	return &SetInspectModeParams{
		Mode: mode,
	}
}

// WithHighlightConfig a descriptor for the highlight appearance of
// hovered-over nodes. May be omitted if enabled == false.
func (p SetInspectModeParams) WithHighlightConfig(highlightConfig *HighlightConfig) *SetInspectModeParams {
	p.HighlightConfig = highlightConfig
	return &p
}

// Do executes DOM.setInspectMode.
func (p *SetInspectModeParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetInspectMode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// HighlightRectParams highlights given rectangle. Coordinates are absolute
// with respect to the main frame viewport.
type HighlightRectParams struct {
	X            int64     `json:"x"`                      // X coordinate
	Y            int64     `json:"y"`                      // Y coordinate
	Width        int64     `json:"width"`                  // Rectangle width
	Height       int64     `json:"height"`                 // Rectangle height
	Color        *cdp.RGBA `json:"color,omitempty"`        // The highlight fill color (default: transparent).
	OutlineColor *cdp.RGBA `json:"outlineColor,omitempty"` // The highlight outline color (default: transparent).
}

// HighlightRect highlights given rectangle. Coordinates are absolute with
// respect to the main frame viewport.
//
// parameters:
//   x - X coordinate
//   y - Y coordinate
//   width - Rectangle width
//   height - Rectangle height
func HighlightRect(x int64, y int64, width int64, height int64) *HighlightRectParams {
	return &HighlightRectParams{
		X:      x,
		Y:      y,
		Width:  width,
		Height: height,
	}
}

// WithColor the highlight fill color (default: transparent).
func (p HighlightRectParams) WithColor(color *cdp.RGBA) *HighlightRectParams {
	p.Color = color
	return &p
}

// WithOutlineColor the highlight outline color (default: transparent).
func (p HighlightRectParams) WithOutlineColor(outlineColor *cdp.RGBA) *HighlightRectParams {
	p.OutlineColor = outlineColor
	return &p
}

// Do executes DOM.highlightRect.
func (p *HighlightRectParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMHighlightRect, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// HighlightQuadParams highlights given quad. Coordinates are absolute with
// respect to the main frame viewport.
type HighlightQuadParams struct {
	Quad         Quad      `json:"quad"`                   // Quad to highlight
	Color        *cdp.RGBA `json:"color,omitempty"`        // The highlight fill color (default: transparent).
	OutlineColor *cdp.RGBA `json:"outlineColor,omitempty"` // The highlight outline color (default: transparent).
}

// HighlightQuad highlights given quad. Coordinates are absolute with respect
// to the main frame viewport.
//
// parameters:
//   quad - Quad to highlight
func HighlightQuad(quad Quad) *HighlightQuadParams {
	return &HighlightQuadParams{
		Quad: quad,
	}
}

// WithColor the highlight fill color (default: transparent).
func (p HighlightQuadParams) WithColor(color *cdp.RGBA) *HighlightQuadParams {
	p.Color = color
	return &p
}

// WithOutlineColor the highlight outline color (default: transparent).
func (p HighlightQuadParams) WithOutlineColor(outlineColor *cdp.RGBA) *HighlightQuadParams {
	p.OutlineColor = outlineColor
	return &p
}

// Do executes DOM.highlightQuad.
func (p *HighlightQuadParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMHighlightQuad, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// HighlightNodeParams highlights DOM node with given id or with the given
// JavaScript object wrapper. Either nodeId or objectId must be specified.
type HighlightNodeParams struct {
	HighlightConfig *HighlightConfig       `json:"highlightConfig"`         // A descriptor for the highlight appearance.
	NodeID          cdp.NodeID             `json:"nodeId,omitempty"`        // Identifier of the node to highlight.
	BackendNodeID   cdp.BackendNodeID      `json:"backendNodeId,omitempty"` // Identifier of the backend node to highlight.
	ObjectID        runtime.RemoteObjectID `json:"objectId,omitempty"`      // JavaScript object id of the node to be highlighted.
}

// HighlightNode highlights DOM node with given id or with the given
// JavaScript object wrapper. Either nodeId or objectId must be specified.
//
// parameters:
//   highlightConfig - A descriptor for the highlight appearance.
func HighlightNode(highlightConfig *HighlightConfig) *HighlightNodeParams {
	return &HighlightNodeParams{
		HighlightConfig: highlightConfig,
	}
}

// WithNodeID identifier of the node to highlight.
func (p HighlightNodeParams) WithNodeID(nodeID cdp.NodeID) *HighlightNodeParams {
	p.NodeID = nodeID
	return &p
}

// WithBackendNodeID identifier of the backend node to highlight.
func (p HighlightNodeParams) WithBackendNodeID(backendNodeID cdp.BackendNodeID) *HighlightNodeParams {
	p.BackendNodeID = backendNodeID
	return &p
}

// WithObjectID javaScript object id of the node to be highlighted.
func (p HighlightNodeParams) WithObjectID(objectID runtime.RemoteObjectID) *HighlightNodeParams {
	p.ObjectID = objectID
	return &p
}

// Do executes DOM.highlightNode.
func (p *HighlightNodeParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMHighlightNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// HideHighlightParams hides DOM node highlight.
type HideHighlightParams struct{}

// HideHighlight hides DOM node highlight.
func HideHighlight() *HideHighlightParams {
	return &HideHighlightParams{}
}

// Do executes DOM.hideHighlight.
func (p *HideHighlightParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMHideHighlight, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// HighlightFrameParams highlights owner element of the frame with given id.
type HighlightFrameParams struct {
	FrameID             cdp.FrameID `json:"frameId"`                       // Identifier of the frame to highlight.
	ContentColor        *cdp.RGBA   `json:"contentColor,omitempty"`        // The content box highlight fill color (default: transparent).
	ContentOutlineColor *cdp.RGBA   `json:"contentOutlineColor,omitempty"` // The content box highlight outline color (default: transparent).
}

// HighlightFrame highlights owner element of the frame with given id.
//
// parameters:
//   frameID - Identifier of the frame to highlight.
func HighlightFrame(frameID cdp.FrameID) *HighlightFrameParams {
	return &HighlightFrameParams{
		FrameID: frameID,
	}
}

// WithContentColor the content box highlight fill color (default:
// transparent).
func (p HighlightFrameParams) WithContentColor(contentColor *cdp.RGBA) *HighlightFrameParams {
	p.ContentColor = contentColor
	return &p
}

// WithContentOutlineColor the content box highlight outline color (default:
// transparent).
func (p HighlightFrameParams) WithContentOutlineColor(contentOutlineColor *cdp.RGBA) *HighlightFrameParams {
	p.ContentOutlineColor = contentOutlineColor
	return &p
}

// Do executes DOM.highlightFrame.
func (p *HighlightFrameParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMHighlightFrame, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// PushNodeByPathToFrontendParams requests that the node is sent to the
// caller given its path. // FIXME, use XPath.
type PushNodeByPathToFrontendParams struct {
	Path string `json:"path"` // Path to node in the proprietary format.
}

// PushNodeByPathToFrontend requests that the node is sent to the caller
// given its path. // FIXME, use XPath.
//
// parameters:
//   path - Path to node in the proprietary format.
func PushNodeByPathToFrontend(path string) *PushNodeByPathToFrontendParams {
	return &PushNodeByPathToFrontendParams{
		Path: path,
	}
}

// PushNodeByPathToFrontendReturns return values.
type PushNodeByPathToFrontendReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // Id of the node for given path.
}

// Do executes DOM.pushNodeByPathToFrontend.
//
// returns:
//   nodeID - Id of the node for given path.
func (p *PushNodeByPathToFrontendParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMPushNodeByPathToFrontend, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r PushNodeByPathToFrontendReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// PushNodesByBackendIdsToFrontendParams requests that a batch of nodes is
// sent to the caller given their backend node ids.
type PushNodesByBackendIdsToFrontendParams struct {
	BackendNodeIds []cdp.BackendNodeID `json:"backendNodeIds"` // The array of backend node ids.
}

// PushNodesByBackendIdsToFrontend requests that a batch of nodes is sent to
// the caller given their backend node ids.
//
// parameters:
//   backendNodeIds - The array of backend node ids.
func PushNodesByBackendIdsToFrontend(backendNodeIds []cdp.BackendNodeID) *PushNodesByBackendIdsToFrontendParams {
	return &PushNodesByBackendIdsToFrontendParams{
		BackendNodeIds: backendNodeIds,
	}
}

// PushNodesByBackendIdsToFrontendReturns return values.
type PushNodesByBackendIdsToFrontendReturns struct {
	NodeIds []cdp.NodeID `json:"nodeIds,omitempty"` // The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
}

// Do executes DOM.pushNodesByBackendIdsToFrontend.
//
// returns:
//   nodeIds - The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds.
func (p *PushNodesByBackendIdsToFrontendParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeIds []cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMPushNodesByBackendIdsToFrontend, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r PushNodesByBackendIdsToFrontendReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.NodeIds, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// SetInspectedNodeParams enables console to refer to the node with given id
// via $x (see Command Line API for more details $x functions).
type SetInspectedNodeParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // DOM node id to be accessible by means of $x command line API.
}

// SetInspectedNode enables console to refer to the node with given id via $x
// (see Command Line API for more details $x functions).
//
// parameters:
//   nodeID - DOM node id to be accessible by means of $x command line API.
func SetInspectedNode(nodeID cdp.NodeID) *SetInspectedNodeParams {
	return &SetInspectedNodeParams{
		NodeID: nodeID,
	}
}

// Do executes DOM.setInspectedNode.
func (p *SetInspectedNodeParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetInspectedNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// ResolveNodeParams resolves JavaScript node object for given node id.
type ResolveNodeParams struct {
	NodeID      cdp.NodeID `json:"nodeId"`                // Id of the node to resolve.
	ObjectGroup string     `json:"objectGroup,omitempty"` // Symbolic group name that can be used to release multiple objects.
}

// ResolveNode resolves JavaScript node object for given node id.
//
// parameters:
//   nodeID - Id of the node to resolve.
func ResolveNode(nodeID cdp.NodeID) *ResolveNodeParams {
	return &ResolveNodeParams{
		NodeID: nodeID,
	}
}

// WithObjectGroup symbolic group name that can be used to release multiple
// objects.
func (p ResolveNodeParams) WithObjectGroup(objectGroup string) *ResolveNodeParams {
	p.ObjectGroup = objectGroup
	return &p
}

// ResolveNodeReturns return values.
type ResolveNodeReturns struct {
	Object *runtime.RemoteObject `json:"object,omitempty"` // JavaScript object wrapper for given node.
}

// Do executes DOM.resolveNode.
//
// returns:
//   object - JavaScript object wrapper for given node.
func (p *ResolveNodeParams) Do(ctxt context.Context, h cdp.FrameHandler) (object *runtime.RemoteObject, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMResolveNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r ResolveNodeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Object, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// GetAttributesParams returns attributes for the specified node.
type GetAttributesParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to retrieve attibutes for.
}

// GetAttributes returns attributes for the specified node.
//
// parameters:
//   nodeID - Id of the node to retrieve attibutes for.
func GetAttributes(nodeID cdp.NodeID) *GetAttributesParams {
	return &GetAttributesParams{
		NodeID: nodeID,
	}
}

// GetAttributesReturns return values.
type GetAttributesReturns struct {
	Attributes []string `json:"attributes,omitempty"` // An interleaved array of node attribute names and values.
}

// Do executes DOM.getAttributes.
//
// returns:
//   attributes - An interleaved array of node attribute names and values.
func (p *GetAttributesParams) Do(ctxt context.Context, h cdp.FrameHandler) (attributes []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetAttributes, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetAttributesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Attributes, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// CopyToParams creates a deep copy of the specified node and places it into
// the target container before the given anchor.
type CopyToParams struct {
	NodeID             cdp.NodeID `json:"nodeId"`                       // Id of the node to copy.
	TargetNodeID       cdp.NodeID `json:"targetNodeId"`                 // Id of the element to drop the copy into.
	InsertBeforeNodeID cdp.NodeID `json:"insertBeforeNodeId,omitempty"` // Drop the copy before this node (if absent, the copy becomes the last child of targetNodeId).
}

// CopyTo creates a deep copy of the specified node and places it into the
// target container before the given anchor.
//
// parameters:
//   nodeID - Id of the node to copy.
//   targetNodeID - Id of the element to drop the copy into.
func CopyTo(nodeID cdp.NodeID, targetNodeID cdp.NodeID) *CopyToParams {
	return &CopyToParams{
		NodeID:       nodeID,
		TargetNodeID: targetNodeID,
	}
}

// WithInsertBeforeNodeID drop the copy before this node (if absent, the copy
// becomes the last child of targetNodeId).
func (p CopyToParams) WithInsertBeforeNodeID(insertBeforeNodeID cdp.NodeID) *CopyToParams {
	p.InsertBeforeNodeID = insertBeforeNodeID
	return &p
}

// CopyToReturns return values.
type CopyToReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // Id of the node clone.
}

// Do executes DOM.copyTo.
//
// returns:
//   nodeID - Id of the node clone.
func (p *CopyToParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMCopyTo, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CopyToReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// MoveToParams moves node into the new container, places it before the given
// anchor.
type MoveToParams struct {
	NodeID             cdp.NodeID `json:"nodeId"`                       // Id of the node to move.
	TargetNodeID       cdp.NodeID `json:"targetNodeId"`                 // Id of the element to drop the moved node into.
	InsertBeforeNodeID cdp.NodeID `json:"insertBeforeNodeId,omitempty"` // Drop node before this one (if absent, the moved node becomes the last child of targetNodeId).
}

// MoveTo moves node into the new container, places it before the given
// anchor.
//
// parameters:
//   nodeID - Id of the node to move.
//   targetNodeID - Id of the element to drop the moved node into.
func MoveTo(nodeID cdp.NodeID, targetNodeID cdp.NodeID) *MoveToParams {
	return &MoveToParams{
		NodeID:       nodeID,
		TargetNodeID: targetNodeID,
	}
}

// WithInsertBeforeNodeID drop node before this one (if absent, the moved
// node becomes the last child of targetNodeId).
func (p MoveToParams) WithInsertBeforeNodeID(insertBeforeNodeID cdp.NodeID) *MoveToParams {
	p.InsertBeforeNodeID = insertBeforeNodeID
	return &p
}

// MoveToReturns return values.
type MoveToReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // New id of the moved node.
}

// Do executes DOM.moveTo.
//
// returns:
//   nodeID - New id of the moved node.
func (p *MoveToParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMMoveTo, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r MoveToReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// UndoParams undoes the last performed action.
type UndoParams struct{}

// Undo undoes the last performed action.
func Undo() *UndoParams {
	return &UndoParams{}
}

// Do executes DOM.undo.
func (p *UndoParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMUndo, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// RedoParams re-does the last undone action.
type RedoParams struct{}

// Redo re-does the last undone action.
func Redo() *RedoParams {
	return &RedoParams{}
}

// Do executes DOM.redo.
func (p *RedoParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMRedo, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// MarkUndoableStateParams marks last undoable state.
type MarkUndoableStateParams struct{}

// MarkUndoableState marks last undoable state.
func MarkUndoableState() *MarkUndoableStateParams {
	return &MarkUndoableStateParams{}
}

// Do executes DOM.markUndoableState.
func (p *MarkUndoableStateParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMMarkUndoableState, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// FocusParams focuses the given element.
type FocusParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to focus.
}

// Focus focuses the given element.
//
// parameters:
//   nodeID - Id of the node to focus.
func Focus(nodeID cdp.NodeID) *FocusParams {
	return &FocusParams{
		NodeID: nodeID,
	}
}

// Do executes DOM.focus.
func (p *FocusParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMFocus, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// SetFileInputFilesParams sets files for the given file input element.
type SetFileInputFilesParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the file input node to set files for.
	Files  []string   `json:"files"`  // Array of file paths to set.
}

// SetFileInputFiles sets files for the given file input element.
//
// parameters:
//   nodeID - Id of the file input node to set files for.
//   files - Array of file paths to set.
func SetFileInputFiles(nodeID cdp.NodeID, files []string) *SetFileInputFilesParams {
	return &SetFileInputFilesParams{
		NodeID: nodeID,
		Files:  files,
	}
}

// Do executes DOM.setFileInputFiles.
func (p *SetFileInputFilesParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMSetFileInputFiles, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// GetBoxModelParams returns boxes for the currently selected nodes.
type GetBoxModelParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to get box model for.
}

// GetBoxModel returns boxes for the currently selected nodes.
//
// parameters:
//   nodeID - Id of the node to get box model for.
func GetBoxModel(nodeID cdp.NodeID) *GetBoxModelParams {
	return &GetBoxModelParams{
		NodeID: nodeID,
	}
}

// GetBoxModelReturns return values.
type GetBoxModelReturns struct {
	Model *BoxModel `json:"model,omitempty"` // Box model for the node.
}

// Do executes DOM.getBoxModel.
//
// returns:
//   model - Box model for the node.
func (p *GetBoxModelParams) Do(ctxt context.Context, h cdp.FrameHandler) (model *BoxModel, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetBoxModel, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetBoxModelReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Model, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// GetNodeForLocationParams returns node id at given location.
type GetNodeForLocationParams struct {
	X int64 `json:"x"` // X coordinate.
	Y int64 `json:"y"` // Y coordinate.
}

// GetNodeForLocation returns node id at given location.
//
// parameters:
//   x - X coordinate.
//   y - Y coordinate.
func GetNodeForLocation(x int64, y int64) *GetNodeForLocationParams {
	return &GetNodeForLocationParams{
		X: x,
		Y: y,
	}
}

// GetNodeForLocationReturns return values.
type GetNodeForLocationReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // Id of the node at given coordinates.
}

// Do executes DOM.getNodeForLocation.
//
// returns:
//   nodeID - Id of the node at given coordinates.
func (p *GetNodeForLocationParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetNodeForLocation, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetNodeForLocationReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// GetRelayoutBoundaryParams returns the id of the nearest ancestor that is a
// relayout boundary.
type GetRelayoutBoundaryParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node.
}

// GetRelayoutBoundary returns the id of the nearest ancestor that is a
// relayout boundary.
//
// parameters:
//   nodeID - Id of the node.
func GetRelayoutBoundary(nodeID cdp.NodeID) *GetRelayoutBoundaryParams {
	return &GetRelayoutBoundaryParams{
		NodeID: nodeID,
	}
}

// GetRelayoutBoundaryReturns return values.
type GetRelayoutBoundaryReturns struct {
	NodeID cdp.NodeID `json:"nodeId,omitempty"` // Relayout boundary node id for the given node.
}

// Do executes DOM.getRelayoutBoundary.
//
// returns:
//   nodeID - Relayout boundary node id for the given node.
func (p *GetRelayoutBoundaryParams) Do(ctxt context.Context, h cdp.FrameHandler) (nodeID cdp.NodeID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return 0, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetRelayoutBoundary, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetRelayoutBoundaryReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, cdp.ErrInvalidResult
			}

			return r.NodeID, nil

		case error:
			return 0, v
		}

	case <-ctxt.Done():
		return 0, cdp.ErrContextDone
	}

	return 0, cdp.ErrUnknownResult
}

// GetHighlightObjectForTestParams for testing.
type GetHighlightObjectForTestParams struct {
	NodeID cdp.NodeID `json:"nodeId"` // Id of the node to get highlight object for.
}

// GetHighlightObjectForTest for testing.
//
// parameters:
//   nodeID - Id of the node to get highlight object for.
func GetHighlightObjectForTest(nodeID cdp.NodeID) *GetHighlightObjectForTestParams {
	return &GetHighlightObjectForTestParams{
		NodeID: nodeID,
	}
}

// GetHighlightObjectForTestReturns return values.
type GetHighlightObjectForTestReturns struct {
	Highlight easyjson.RawMessage `json:"highlight,omitempty"`
}

// Do executes DOM.getHighlightObjectForTest.
//
// returns:
//   highlight - Highlight data for the node.
func (p *GetHighlightObjectForTestParams) Do(ctxt context.Context, h cdp.FrameHandler) (highlight easyjson.RawMessage, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandDOMGetHighlightObjectForTest, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetHighlightObjectForTestReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Highlight, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}
