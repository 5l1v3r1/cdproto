// Package target provides the Chrome Debugging Protocol
// commands, types, and events for the Target domain.
//
// Supports additional targets discovery and allows to attach to them.
//
// Generated by the chromedp-gen command.
package target

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

// SetDiscoverTargetsParams controls whether to discover available targets
// and notify via targetCreated/targetDestroyed events.
type SetDiscoverTargetsParams struct {
	Discover bool `json:"discover"` // Whether to discover available targets.
}

// SetDiscoverTargets controls whether to discover available targets and
// notify via targetCreated/targetDestroyed events.
//
// parameters:
//   discover - Whether to discover available targets.
func SetDiscoverTargets(discover bool) *SetDiscoverTargetsParams {
	return &SetDiscoverTargetsParams{
		Discover: discover,
	}
}

// Do executes Target.setDiscoverTargets against the provided context and
// target handler.
func (p *SetDiscoverTargetsParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetSetDiscoverTargets, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetAutoAttachParams controls whether to automatically attach to new
// targets which are considered to be related to this one. When turned on,
// attaches to all existing related targets as well. When turned off,
// automatically detaches from all currently attached targets.
type SetAutoAttachParams struct {
	AutoAttach             bool `json:"autoAttach"`             // Whether to auto-attach to related targets.
	WaitForDebuggerOnStart bool `json:"waitForDebuggerOnStart"` // Whether to pause new targets when attaching to them. Use Runtime.runIfWaitingForDebugger to run paused targets.
}

// SetAutoAttach controls whether to automatically attach to new targets
// which are considered to be related to this one. When turned on, attaches to
// all existing related targets as well. When turned off, automatically detaches
// from all currently attached targets.
//
// parameters:
//   autoAttach - Whether to auto-attach to related targets.
//   waitForDebuggerOnStart - Whether to pause new targets when attaching to them. Use Runtime.runIfWaitingForDebugger to run paused targets.
func SetAutoAttach(autoAttach bool, waitForDebuggerOnStart bool) *SetAutoAttachParams {
	return &SetAutoAttachParams{
		AutoAttach:             autoAttach,
		WaitForDebuggerOnStart: waitForDebuggerOnStart,
	}
}

// Do executes Target.setAutoAttach against the provided context and
// target handler.
func (p *SetAutoAttachParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetSetAutoAttach, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetAttachToFramesParams [no description].
type SetAttachToFramesParams struct {
	Value bool `json:"value"` // Whether to attach to frames.
}

// SetAttachToFrames [no description].
//
// parameters:
//   value - Whether to attach to frames.
func SetAttachToFrames(value bool) *SetAttachToFramesParams {
	return &SetAttachToFramesParams{
		Value: value,
	}
}

// Do executes Target.setAttachToFrames against the provided context and
// target handler.
func (p *SetAttachToFramesParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetSetAttachToFrames, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetRemoteLocationsParams enables target discovery for the specified
// locations, when setDiscoverTargets was set to true.
type SetRemoteLocationsParams struct {
	Locations []*RemoteLocation `json:"locations"` // List of remote locations.
}

// SetRemoteLocations enables target discovery for the specified locations,
// when setDiscoverTargets was set to true.
//
// parameters:
//   locations - List of remote locations.
func SetRemoteLocations(locations []*RemoteLocation) *SetRemoteLocationsParams {
	return &SetRemoteLocationsParams{
		Locations: locations,
	}
}

// Do executes Target.setRemoteLocations against the provided context and
// target handler.
func (p *SetRemoteLocationsParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetSetRemoteLocations, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SendMessageToTargetParams sends protocol message to the target with given
// id.
type SendMessageToTargetParams struct {
	TargetID string `json:"targetId"`
	Message  string `json:"message"`
}

// SendMessageToTarget sends protocol message to the target with given id.
//
// parameters:
//   targetID
//   message
func SendMessageToTarget(targetID string, message string) *SendMessageToTargetParams {
	return &SendMessageToTargetParams{
		TargetID: targetID,
		Message:  message,
	}
}

// Do executes Target.sendMessageToTarget against the provided context and
// target handler.
func (p *SendMessageToTargetParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetSendMessageToTarget, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// GetTargetInfoParams returns information about a target.
type GetTargetInfoParams struct {
	TargetID ID `json:"targetId"`
}

// GetTargetInfo returns information about a target.
//
// parameters:
//   targetID
func GetTargetInfo(targetID ID) *GetTargetInfoParams {
	return &GetTargetInfoParams{
		TargetID: targetID,
	}
}

// GetTargetInfoReturns return values.
type GetTargetInfoReturns struct {
	TargetInfo *Info `json:"targetInfo,omitempty"`
}

// Do executes Target.getTargetInfo against the provided context and
// target handler.
//
// returns:
//   targetInfo
func (p *GetTargetInfoParams) Do(ctxt context.Context, h cdp.Handler) (targetInfo *Info, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetGetTargetInfo, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetTargetInfoReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.TargetInfo, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}

// ActivateTargetParams activates (focuses) the target.
type ActivateTargetParams struct {
	TargetID ID `json:"targetId"`
}

// ActivateTarget activates (focuses) the target.
//
// parameters:
//   targetID
func ActivateTarget(targetID ID) *ActivateTargetParams {
	return &ActivateTargetParams{
		TargetID: targetID,
	}
}

// Do executes Target.activateTarget against the provided context and
// target handler.
func (p *ActivateTargetParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetActivateTarget, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// CloseTargetParams closes the target. If the target is a page that gets
// closed too.
type CloseTargetParams struct {
	TargetID ID `json:"targetId"`
}

// CloseTarget closes the target. If the target is a page that gets closed
// too.
//
// parameters:
//   targetID
func CloseTarget(targetID ID) *CloseTargetParams {
	return &CloseTargetParams{
		TargetID: targetID,
	}
}

// CloseTargetReturns return values.
type CloseTargetReturns struct {
	Success bool `json:"success,omitempty"`
}

// Do executes Target.closeTarget against the provided context and
// target handler.
//
// returns:
//   success
func (p *CloseTargetParams) Do(ctxt context.Context, h cdp.Handler) (success bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return false, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetCloseTarget, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CloseTargetReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return false, cdp.ErrInvalidResult
			}

			return r.Success, nil

		case error:
			return false, v
		}

	case <-ctxt.Done():
		return false, ctxt.Err()
	}

	return false, cdp.ErrUnknownResult
}

// AttachToTargetParams attaches to the target with given id.
type AttachToTargetParams struct {
	TargetID ID `json:"targetId"`
}

// AttachToTarget attaches to the target with given id.
//
// parameters:
//   targetID
func AttachToTarget(targetID ID) *AttachToTargetParams {
	return &AttachToTargetParams{
		TargetID: targetID,
	}
}

// AttachToTargetReturns return values.
type AttachToTargetReturns struct {
	Success bool `json:"success,omitempty"` // Whether attach succeeded.
}

// Do executes Target.attachToTarget against the provided context and
// target handler.
//
// returns:
//   success - Whether attach succeeded.
func (p *AttachToTargetParams) Do(ctxt context.Context, h cdp.Handler) (success bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return false, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetAttachToTarget, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r AttachToTargetReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return false, cdp.ErrInvalidResult
			}

			return r.Success, nil

		case error:
			return false, v
		}

	case <-ctxt.Done():
		return false, ctxt.Err()
	}

	return false, cdp.ErrUnknownResult
}

// DetachFromTargetParams detaches from the target with given id.
type DetachFromTargetParams struct {
	TargetID ID `json:"targetId"`
}

// DetachFromTarget detaches from the target with given id.
//
// parameters:
//   targetID
func DetachFromTarget(targetID ID) *DetachFromTargetParams {
	return &DetachFromTargetParams{
		TargetID: targetID,
	}
}

// Do executes Target.detachFromTarget against the provided context and
// target handler.
func (p *DetachFromTargetParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetDetachFromTarget, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// CreateBrowserContextParams creates a new empty BrowserContext. Similar to
// an incognito profile but you can have more than one.
type CreateBrowserContextParams struct{}

// CreateBrowserContext creates a new empty BrowserContext. Similar to an
// incognito profile but you can have more than one.
func CreateBrowserContext() *CreateBrowserContextParams {
	return &CreateBrowserContextParams{}
}

// CreateBrowserContextReturns return values.
type CreateBrowserContextReturns struct {
	BrowserContextID BrowserContextID `json:"browserContextId,omitempty"` // The id of the context created.
}

// Do executes Target.createBrowserContext against the provided context and
// target handler.
//
// returns:
//   browserContextID - The id of the context created.
func (p *CreateBrowserContextParams) Do(ctxt context.Context, h cdp.Handler) (browserContextID BrowserContextID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetCreateBrowserContext, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CreateBrowserContextReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", cdp.ErrInvalidResult
			}

			return r.BrowserContextID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ctxt.Err()
	}

	return "", cdp.ErrUnknownResult
}

// DisposeBrowserContextParams deletes a BrowserContext, will fail of any
// open page uses it.
type DisposeBrowserContextParams struct {
	BrowserContextID BrowserContextID `json:"browserContextId"`
}

// DisposeBrowserContext deletes a BrowserContext, will fail of any open page
// uses it.
//
// parameters:
//   browserContextID
func DisposeBrowserContext(browserContextID BrowserContextID) *DisposeBrowserContextParams {
	return &DisposeBrowserContextParams{
		BrowserContextID: browserContextID,
	}
}

// DisposeBrowserContextReturns return values.
type DisposeBrowserContextReturns struct {
	Success bool `json:"success,omitempty"`
}

// Do executes Target.disposeBrowserContext against the provided context and
// target handler.
//
// returns:
//   success
func (p *DisposeBrowserContextParams) Do(ctxt context.Context, h cdp.Handler) (success bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return false, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetDisposeBrowserContext, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r DisposeBrowserContextReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return false, cdp.ErrInvalidResult
			}

			return r.Success, nil

		case error:
			return false, v
		}

	case <-ctxt.Done():
		return false, ctxt.Err()
	}

	return false, cdp.ErrUnknownResult
}

// CreateTargetParams creates a new page.
type CreateTargetParams struct {
	URL              string           `json:"url"`                        // The initial URL the page will be navigated to.
	Width            int64            `json:"width,omitempty"`            // Frame width in DIP (headless chrome only).
	Height           int64            `json:"height,omitempty"`           // Frame height in DIP (headless chrome only).
	BrowserContextID BrowserContextID `json:"browserContextId,omitempty"` // The browser context to create the page in (headless chrome only).
}

// CreateTarget creates a new page.
//
// parameters:
//   url - The initial URL the page will be navigated to.
func CreateTarget(url string) *CreateTargetParams {
	return &CreateTargetParams{
		URL: url,
	}
}

// WithWidth frame width in DIP (headless chrome only).
func (p CreateTargetParams) WithWidth(width int64) *CreateTargetParams {
	p.Width = width
	return &p
}

// WithHeight frame height in DIP (headless chrome only).
func (p CreateTargetParams) WithHeight(height int64) *CreateTargetParams {
	p.Height = height
	return &p
}

// WithBrowserContextID the browser context to create the page in (headless
// chrome only).
func (p CreateTargetParams) WithBrowserContextID(browserContextID BrowserContextID) *CreateTargetParams {
	p.BrowserContextID = browserContextID
	return &p
}

// CreateTargetReturns return values.
type CreateTargetReturns struct {
	TargetID ID `json:"targetId,omitempty"` // The id of the page opened.
}

// Do executes Target.createTarget against the provided context and
// target handler.
//
// returns:
//   targetID - The id of the page opened.
func (p *CreateTargetParams) Do(ctxt context.Context, h cdp.Handler) (targetID ID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetCreateTarget, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CreateTargetReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", cdp.ErrInvalidResult
			}

			return r.TargetID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ctxt.Err()
	}

	return "", cdp.ErrUnknownResult
}

// GetTargetsParams retrieves a list of available targets.
type GetTargetsParams struct{}

// GetTargets retrieves a list of available targets.
func GetTargets() *GetTargetsParams {
	return &GetTargetsParams{}
}

// GetTargetsReturns return values.
type GetTargetsReturns struct {
	TargetInfos []*Info `json:"targetInfos,omitempty"` // The list of targets.
}

// Do executes Target.getTargets against the provided context and
// target handler.
//
// returns:
//   targetInfos - The list of targets.
func (p *GetTargetsParams) Do(ctxt context.Context, h cdp.Handler) (targetInfos []*Info, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandTargetGetTargets, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetTargetsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.TargetInfos, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}
