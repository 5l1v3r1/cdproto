// Package heapprofiler provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome HeapProfiler domain.
//
// Generated by the chromedp-gen command.
package heapprofiler

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/knq/chromedp/cdp/runtime"
	"github.com/mailru/easyjson"
)

// EnableParams [no description].
type EnableParams struct{}

// Enable [no description].
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes HeapProfiler.enable.
func (p *EnableParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerEnable, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// DisableParams [no description].
type DisableParams struct{}

// Disable [no description].
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes HeapProfiler.disable.
func (p *DisableParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerDisable, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// StartTrackingHeapObjectsParams [no description].
type StartTrackingHeapObjectsParams struct {
	TrackAllocations bool `json:"trackAllocations,omitempty"`
}

// StartTrackingHeapObjects [no description].
//
// parameters:
func StartTrackingHeapObjects() *StartTrackingHeapObjectsParams {
	return &StartTrackingHeapObjectsParams{}
}

// WithTrackAllocations [no description].
func (p StartTrackingHeapObjectsParams) WithTrackAllocations(trackAllocations bool) *StartTrackingHeapObjectsParams {
	p.TrackAllocations = trackAllocations
	return &p
}

// Do executes HeapProfiler.startTrackingHeapObjects.
func (p *StartTrackingHeapObjectsParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerStartTrackingHeapObjects, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// StopTrackingHeapObjectsParams [no description].
type StopTrackingHeapObjectsParams struct {
	ReportProgress bool `json:"reportProgress,omitempty"` // If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
}

// StopTrackingHeapObjects [no description].
//
// parameters:
func StopTrackingHeapObjects() *StopTrackingHeapObjectsParams {
	return &StopTrackingHeapObjectsParams{}
}

// WithReportProgress if true 'reportHeapSnapshotProgress' events will be
// generated while snapshot is being taken when the tracking is stopped.
func (p StopTrackingHeapObjectsParams) WithReportProgress(reportProgress bool) *StopTrackingHeapObjectsParams {
	p.ReportProgress = reportProgress
	return &p
}

// Do executes HeapProfiler.stopTrackingHeapObjects.
func (p *StopTrackingHeapObjectsParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerStopTrackingHeapObjects, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// TakeHeapSnapshotParams [no description].
type TakeHeapSnapshotParams struct {
	ReportProgress bool `json:"reportProgress,omitempty"` // If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
}

// TakeHeapSnapshot [no description].
//
// parameters:
func TakeHeapSnapshot() *TakeHeapSnapshotParams {
	return &TakeHeapSnapshotParams{}
}

// WithReportProgress if true 'reportHeapSnapshotProgress' events will be
// generated while snapshot is being taken.
func (p TakeHeapSnapshotParams) WithReportProgress(reportProgress bool) *TakeHeapSnapshotParams {
	p.ReportProgress = reportProgress
	return &p
}

// Do executes HeapProfiler.takeHeapSnapshot.
func (p *TakeHeapSnapshotParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerTakeHeapSnapshot, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// CollectGarbageParams [no description].
type CollectGarbageParams struct{}

// CollectGarbage [no description].
func CollectGarbage() *CollectGarbageParams {
	return &CollectGarbageParams{}
}

// Do executes HeapProfiler.collectGarbage.
func (p *CollectGarbageParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerCollectGarbage, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// GetObjectByHeapObjectIDParams [no description].
type GetObjectByHeapObjectIDParams struct {
	ObjectID    HeapSnapshotObjectID `json:"objectId"`
	ObjectGroup string               `json:"objectGroup,omitempty"` // Symbolic group name that can be used to release multiple objects.
}

// GetObjectByHeapObjectID [no description].
//
// parameters:
//   objectID
func GetObjectByHeapObjectID(objectID HeapSnapshotObjectID) *GetObjectByHeapObjectIDParams {
	return &GetObjectByHeapObjectIDParams{
		ObjectID: objectID,
	}
}

// WithObjectGroup symbolic group name that can be used to release multiple
// objects.
func (p GetObjectByHeapObjectIDParams) WithObjectGroup(objectGroup string) *GetObjectByHeapObjectIDParams {
	p.ObjectGroup = objectGroup
	return &p
}

// GetObjectByHeapObjectIDReturns return values.
type GetObjectByHeapObjectIDReturns struct {
	Result *runtime.RemoteObject `json:"result,omitempty"` // Evaluation result.
}

// Do executes HeapProfiler.getObjectByHeapObjectId.
//
// returns:
//   result - Evaluation result.
func (p *GetObjectByHeapObjectIDParams) Do(ctxt context.Context, h cdp.FrameHandler) (result *runtime.RemoteObject, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerGetObjectByHeapObjectID, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetObjectByHeapObjectIDReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Result, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}

// AddInspectedHeapObjectParams enables console to refer to the node with
// given id via $x (see Command Line API for more details $x functions).
type AddInspectedHeapObjectParams struct {
	HeapObjectID HeapSnapshotObjectID `json:"heapObjectId"` // Heap snapshot object id to be accessible by means of $x command line API.
}

// AddInspectedHeapObject enables console to refer to the node with given id
// via $x (see Command Line API for more details $x functions).
//
// parameters:
//   heapObjectID - Heap snapshot object id to be accessible by means of $x command line API.
func AddInspectedHeapObject(heapObjectID HeapSnapshotObjectID) *AddInspectedHeapObjectParams {
	return &AddInspectedHeapObjectParams{
		HeapObjectID: heapObjectID,
	}
}

// Do executes HeapProfiler.addInspectedHeapObject.
func (p *AddInspectedHeapObjectParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerAddInspectedHeapObject, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// GetHeapObjectIDParams [no description].
type GetHeapObjectIDParams struct {
	ObjectID runtime.RemoteObjectID `json:"objectId"` // Identifier of the object to get heap object id for.
}

// GetHeapObjectID [no description].
//
// parameters:
//   objectID - Identifier of the object to get heap object id for.
func GetHeapObjectID(objectID runtime.RemoteObjectID) *GetHeapObjectIDParams {
	return &GetHeapObjectIDParams{
		ObjectID: objectID,
	}
}

// GetHeapObjectIDReturns return values.
type GetHeapObjectIDReturns struct {
	HeapSnapshotObjectID HeapSnapshotObjectID `json:"heapSnapshotObjectId,omitempty"` // Id of the heap snapshot object corresponding to the passed remote object id.
}

// Do executes HeapProfiler.getHeapObjectId.
//
// returns:
//   heapSnapshotObjectID - Id of the heap snapshot object corresponding to the passed remote object id.
func (p *GetHeapObjectIDParams) Do(ctxt context.Context, h cdp.FrameHandler) (heapSnapshotObjectID HeapSnapshotObjectID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerGetHeapObjectID, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetHeapObjectIDReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", cdp.ErrInvalidResult
			}

			return r.HeapSnapshotObjectID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", cdp.ErrContextDone
	}

	return "", cdp.ErrUnknownResult
}

// StartSamplingParams [no description].
type StartSamplingParams struct {
	SamplingInterval float64 `json:"samplingInterval,omitempty"` // Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
}

// StartSampling [no description].
//
// parameters:
func StartSampling() *StartSamplingParams {
	return &StartSamplingParams{}
}

// WithSamplingInterval average sample interval in bytes. Poisson
// distribution is used for the intervals. The default value is 32768 bytes.
func (p StartSamplingParams) WithSamplingInterval(samplingInterval float64) *StartSamplingParams {
	p.SamplingInterval = samplingInterval
	return &p
}

// Do executes HeapProfiler.startSampling.
func (p *StartSamplingParams) Do(ctxt context.Context, h cdp.FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerStartSampling, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return cdp.ErrContextDone
	}

	return cdp.ErrUnknownResult
}

// StopSamplingParams [no description].
type StopSamplingParams struct{}

// StopSampling [no description].
func StopSampling() *StopSamplingParams {
	return &StopSamplingParams{}
}

// StopSamplingReturns return values.
type StopSamplingReturns struct {
	Profile *SamplingHeapProfile `json:"profile,omitempty"` // Recorded sampling heap profile.
}

// Do executes HeapProfiler.stopSampling.
//
// returns:
//   profile - Recorded sampling heap profile.
func (p *StopSamplingParams) Do(ctxt context.Context, h cdp.FrameHandler) (profile *SamplingHeapProfile, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandHeapProfilerStopSampling, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r StopSamplingReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Profile, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, cdp.ErrContextDone
	}

	return nil, cdp.ErrUnknownResult
}
