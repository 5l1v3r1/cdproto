// Package heapprofiler provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome HeapProfiler domain.
//
// Generated by the chromedp-gen command.
package heapprofiler

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/knq/chromedp/cdp/runtime"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

type EnableParams struct{}

func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes HeapProfiler.enable.
func (p *EnableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerEnable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type DisableParams struct{}

func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes HeapProfiler.disable.
func (p *DisableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerDisable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type StartTrackingHeapObjectsParams struct {
	TrackAllocations bool `json:"trackAllocations,omitempty"`
}

// parameters:
func StartTrackingHeapObjects() *StartTrackingHeapObjectsParams {
	return &StartTrackingHeapObjectsParams{}
}

func (p StartTrackingHeapObjectsParams) WithTrackAllocations(trackAllocations bool) *StartTrackingHeapObjectsParams {
	p.TrackAllocations = trackAllocations
	return &p
}

// Do executes HeapProfiler.startTrackingHeapObjects.
func (p *StartTrackingHeapObjectsParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerStartTrackingHeapObjects, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type StopTrackingHeapObjectsParams struct {
	ReportProgress bool `json:"reportProgress,omitempty"` // If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
}

// parameters:
func StopTrackingHeapObjects() *StopTrackingHeapObjectsParams {
	return &StopTrackingHeapObjectsParams{}
}

// WithReportProgress if true 'reportHeapSnapshotProgress' events will be
// generated while snapshot is being taken when the tracking is stopped.
func (p StopTrackingHeapObjectsParams) WithReportProgress(reportProgress bool) *StopTrackingHeapObjectsParams {
	p.ReportProgress = reportProgress
	return &p
}

// Do executes HeapProfiler.stopTrackingHeapObjects.
func (p *StopTrackingHeapObjectsParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerStopTrackingHeapObjects, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type TakeHeapSnapshotParams struct {
	ReportProgress bool `json:"reportProgress,omitempty"` // If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
}

// parameters:
func TakeHeapSnapshot() *TakeHeapSnapshotParams {
	return &TakeHeapSnapshotParams{}
}

// WithReportProgress if true 'reportHeapSnapshotProgress' events will be
// generated while snapshot is being taken.
func (p TakeHeapSnapshotParams) WithReportProgress(reportProgress bool) *TakeHeapSnapshotParams {
	p.ReportProgress = reportProgress
	return &p
}

// Do executes HeapProfiler.takeHeapSnapshot.
func (p *TakeHeapSnapshotParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerTakeHeapSnapshot, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type CollectGarbageParams struct{}

func CollectGarbage() *CollectGarbageParams {
	return &CollectGarbageParams{}
}

// Do executes HeapProfiler.collectGarbage.
func (p *CollectGarbageParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerCollectGarbage, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type GetObjectByHeapObjectIDParams struct {
	ObjectID    HeapSnapshotObjectID `json:"objectId"`
	ObjectGroup string               `json:"objectGroup,omitempty"` // Symbolic group name that can be used to release multiple objects.
}

// parameters:
//   objectId
func GetObjectByHeapObjectID(objectId HeapSnapshotObjectID) *GetObjectByHeapObjectIDParams {
	return &GetObjectByHeapObjectIDParams{
		ObjectID: objectId,
	}
}

// WithObjectGroup symbolic group name that can be used to release multiple
// objects.
func (p GetObjectByHeapObjectIDParams) WithObjectGroup(objectGroup string) *GetObjectByHeapObjectIDParams {
	p.ObjectGroup = objectGroup
	return &p
}

// GetObjectByHeapObjectIDReturns return values.
type GetObjectByHeapObjectIDReturns struct {
	Result *runtime.RemoteObject `json:"result,omitempty"` // Evaluation result.
}

// Do executes HeapProfiler.getObjectByHeapObjectId.
//
// returns:
//   result - Evaluation result.
func (p *GetObjectByHeapObjectIDParams) Do(ctxt context.Context, h FrameHandler) (result *runtime.RemoteObject, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerGetObjectByHeapObjectID, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetObjectByHeapObjectIDReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Result, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// AddInspectedHeapObjectParams enables console to refer to the node with
// given id via $x (see Command Line API for more details $x functions).
type AddInspectedHeapObjectParams struct {
	HeapObjectID HeapSnapshotObjectID `json:"heapObjectId"` // Heap snapshot object id to be accessible by means of $x command line API.
}

// AddInspectedHeapObject enables console to refer to the node with given id
// via $x (see Command Line API for more details $x functions).
//
// parameters:
//   heapObjectId - Heap snapshot object id to be accessible by means of $x command line API.
func AddInspectedHeapObject(heapObjectId HeapSnapshotObjectID) *AddInspectedHeapObjectParams {
	return &AddInspectedHeapObjectParams{
		HeapObjectID: heapObjectId,
	}
}

// Do executes HeapProfiler.addInspectedHeapObject.
func (p *AddInspectedHeapObjectParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerAddInspectedHeapObject, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type GetHeapObjectIDParams struct {
	ObjectID runtime.RemoteObjectID `json:"objectId"` // Identifier of the object to get heap object id for.
}

// parameters:
//   objectId - Identifier of the object to get heap object id for.
func GetHeapObjectID(objectId runtime.RemoteObjectID) *GetHeapObjectIDParams {
	return &GetHeapObjectIDParams{
		ObjectID: objectId,
	}
}

// GetHeapObjectIDReturns return values.
type GetHeapObjectIDReturns struct {
	HeapSnapshotObjectID HeapSnapshotObjectID `json:"heapSnapshotObjectId,omitempty"` // Id of the heap snapshot object corresponding to the passed remote object id.
}

// Do executes HeapProfiler.getHeapObjectId.
//
// returns:
//   heapSnapshotObjectId - Id of the heap snapshot object corresponding to the passed remote object id.
func (p *GetHeapObjectIDParams) Do(ctxt context.Context, h FrameHandler) (heapSnapshotObjectId HeapSnapshotObjectID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerGetHeapObjectID, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetHeapObjectIDReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.HeapSnapshotObjectID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

type StartSamplingParams struct {
	SamplingInterval float64 `json:"samplingInterval,omitempty"` // Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
}

// parameters:
func StartSampling() *StartSamplingParams {
	return &StartSamplingParams{}
}

// WithSamplingInterval average sample interval in bytes. Poisson
// distribution is used for the intervals. The default value is 32768 bytes.
func (p StartSamplingParams) WithSamplingInterval(samplingInterval float64) *StartSamplingParams {
	p.SamplingInterval = samplingInterval
	return &p
}

// Do executes HeapProfiler.startSampling.
func (p *StartSamplingParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerStartSampling, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type StopSamplingParams struct{}

func StopSampling() *StopSamplingParams {
	return &StopSamplingParams{}
}

// StopSamplingReturns return values.
type StopSamplingReturns struct {
	Profile *SamplingHeapProfile `json:"profile,omitempty"` // Recorded sampling heap profile.
}

// Do executes HeapProfiler.stopSampling.
//
// returns:
//   profile - Recorded sampling heap profile.
func (p *StopSamplingParams) Do(ctxt context.Context, h FrameHandler) (profile *SamplingHeapProfile, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandHeapProfilerStopSampling, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r StopSamplingReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Profile, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}
