// Package network provides the Chrome Debugging Protocol
// commands, types, and events for the Network domain.
//
// Network domain allows tracking network activities of the page. It exposes
// information about http, file, data and other requests and responses, their
// headers, bodies, timing, etc.
//
// Generated by the chromedp-gen command.
package network

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"
	"encoding/base64"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

// EnableParams enables network tracking, network events will now be
// delivered to the client.
type EnableParams struct {
	MaxTotalBufferSize    int64 `json:"maxTotalBufferSize,omitempty"`    // Buffer size in bytes to use when preserving network payloads (XHRs, etc).
	MaxResourceBufferSize int64 `json:"maxResourceBufferSize,omitempty"` // Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
}

// Enable enables network tracking, network events will now be delivered to
// the client.
//
// parameters:
func Enable() *EnableParams {
	return &EnableParams{}
}

// WithMaxTotalBufferSize buffer size in bytes to use when preserving network
// payloads (XHRs, etc).
func (p EnableParams) WithMaxTotalBufferSize(maxTotalBufferSize int64) *EnableParams {
	p.MaxTotalBufferSize = maxTotalBufferSize
	return &p
}

// WithMaxResourceBufferSize per-resource buffer size in bytes to use when
// preserving network payloads (XHRs, etc).
func (p EnableParams) WithMaxResourceBufferSize(maxResourceBufferSize int64) *EnableParams {
	p.MaxResourceBufferSize = maxResourceBufferSize
	return &p
}

// Do executes Network.enable against the provided context and
// target handler.
func (p *EnableParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkEnable, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// DisableParams disables network tracking, prevents network events from
// being sent to the client.
type DisableParams struct{}

// Disable disables network tracking, prevents network events from being sent
// to the client.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes Network.disable against the provided context and
// target handler.
func (p *DisableParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkDisable, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetUserAgentOverrideParams allows overriding user agent with the given
// string.
type SetUserAgentOverrideParams struct {
	UserAgent string `json:"userAgent"` // User agent to use.
}

// SetUserAgentOverride allows overriding user agent with the given string.
//
// parameters:
//   userAgent - User agent to use.
func SetUserAgentOverride(userAgent string) *SetUserAgentOverrideParams {
	return &SetUserAgentOverrideParams{
		UserAgent: userAgent,
	}
}

// Do executes Network.setUserAgentOverride against the provided context and
// target handler.
func (p *SetUserAgentOverrideParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkSetUserAgentOverride, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetExtraHTTPHeadersParams specifies whether to always send extra HTTP
// headers with the requests from this page.
type SetExtraHTTPHeadersParams struct {
	Headers *Headers `json:"headers"` // Map with extra HTTP headers.
}

// SetExtraHTTPHeaders specifies whether to always send extra HTTP headers
// with the requests from this page.
//
// parameters:
//   headers - Map with extra HTTP headers.
func SetExtraHTTPHeaders(headers *Headers) *SetExtraHTTPHeadersParams {
	return &SetExtraHTTPHeadersParams{
		Headers: headers,
	}
}

// Do executes Network.setExtraHTTPHeaders against the provided context and
// target handler.
func (p *SetExtraHTTPHeadersParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkSetExtraHTTPHeaders, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// GetResponseBodyParams returns content served for the given request.
type GetResponseBodyParams struct {
	RequestID RequestID `json:"requestId"` // Identifier of the network request to get content for.
}

// GetResponseBody returns content served for the given request.
//
// parameters:
//   requestID - Identifier of the network request to get content for.
func GetResponseBody(requestID RequestID) *GetResponseBodyParams {
	return &GetResponseBodyParams{
		RequestID: requestID,
	}
}

// GetResponseBodyReturns return values.
type GetResponseBodyReturns struct {
	Body          string `json:"body,omitempty"`          // Response body.
	Base64encoded bool   `json:"base64Encoded,omitempty"` // True, if content was sent as base64.
}

// Do executes Network.getResponseBody against the provided context and
// target handler.
//
// returns:
//   body - Response body.
func (p *GetResponseBodyParams) Do(ctxt context.Context, h cdp.Handler) (body []byte, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkGetResponseBody, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetResponseBodyReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			// decode
			var dec []byte
			if r.Base64encoded {
				dec, err = base64.StdEncoding.DecodeString(r.Body)
				if err != nil {
					return nil, err
				}
			} else {
				dec = []byte(r.Body)
			}

			return dec, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}

// AddBlockedURLParams blocks specific URL from loading.
type AddBlockedURLParams struct {
	URL string `json:"url"` // URL to block.
}

// AddBlockedURL blocks specific URL from loading.
//
// parameters:
//   url - URL to block.
func AddBlockedURL(url string) *AddBlockedURLParams {
	return &AddBlockedURLParams{
		URL: url,
	}
}

// Do executes Network.addBlockedURL against the provided context and
// target handler.
func (p *AddBlockedURLParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkAddBlockedURL, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// RemoveBlockedURLParams cancels blocking of a specific URL from loading.
type RemoveBlockedURLParams struct {
	URL string `json:"url"` // URL to stop blocking.
}

// RemoveBlockedURL cancels blocking of a specific URL from loading.
//
// parameters:
//   url - URL to stop blocking.
func RemoveBlockedURL(url string) *RemoveBlockedURLParams {
	return &RemoveBlockedURLParams{
		URL: url,
	}
}

// Do executes Network.removeBlockedURL against the provided context and
// target handler.
func (p *RemoveBlockedURLParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkRemoveBlockedURL, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// ReplayXHRParams this method sends a new XMLHttpRequest which is identical
// to the original one. The following parameters should be identical: method,
// url, async, request body, extra headers, withCredentials attribute, user,
// password.
type ReplayXHRParams struct {
	RequestID RequestID `json:"requestId"` // Identifier of XHR to replay.
}

// ReplayXHR this method sends a new XMLHttpRequest which is identical to the
// original one. The following parameters should be identical: method, url,
// async, request body, extra headers, withCredentials attribute, user,
// password.
//
// parameters:
//   requestID - Identifier of XHR to replay.
func ReplayXHR(requestID RequestID) *ReplayXHRParams {
	return &ReplayXHRParams{
		RequestID: requestID,
	}
}

// Do executes Network.replayXHR against the provided context and
// target handler.
func (p *ReplayXHRParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkReplayXHR, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetMonitoringXHREnabledParams toggles monitoring of XMLHttpRequest. If
// true, console will receive messages upon each XHR issued.
type SetMonitoringXHREnabledParams struct {
	Enabled bool `json:"enabled"` // Monitoring enabled state.
}

// SetMonitoringXHREnabled toggles monitoring of XMLHttpRequest. If true,
// console will receive messages upon each XHR issued.
//
// parameters:
//   enabled - Monitoring enabled state.
func SetMonitoringXHREnabled(enabled bool) *SetMonitoringXHREnabledParams {
	return &SetMonitoringXHREnabledParams{
		Enabled: enabled,
	}
}

// Do executes Network.setMonitoringXHREnabled against the provided context and
// target handler.
func (p *SetMonitoringXHREnabledParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkSetMonitoringXHREnabled, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// CanClearBrowserCacheParams tells whether clearing browser cache is
// supported.
type CanClearBrowserCacheParams struct{}

// CanClearBrowserCache tells whether clearing browser cache is supported.
func CanClearBrowserCache() *CanClearBrowserCacheParams {
	return &CanClearBrowserCacheParams{}
}

// CanClearBrowserCacheReturns return values.
type CanClearBrowserCacheReturns struct {
	Result bool `json:"result,omitempty"` // True if browser cache can be cleared.
}

// Do executes Network.canClearBrowserCache against the provided context and
// target handler.
//
// returns:
//   result - True if browser cache can be cleared.
func (p *CanClearBrowserCacheParams) Do(ctxt context.Context, h cdp.Handler) (result bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkCanClearBrowserCache, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CanClearBrowserCacheReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return false, cdp.ErrInvalidResult
			}

			return r.Result, nil

		case error:
			return false, v
		}

	case <-ctxt.Done():
		return false, ctxt.Err()
	}

	return false, cdp.ErrUnknownResult
}

// ClearBrowserCacheParams clears browser cache.
type ClearBrowserCacheParams struct{}

// ClearBrowserCache clears browser cache.
func ClearBrowserCache() *ClearBrowserCacheParams {
	return &ClearBrowserCacheParams{}
}

// Do executes Network.clearBrowserCache against the provided context and
// target handler.
func (p *ClearBrowserCacheParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkClearBrowserCache, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// CanClearBrowserCookiesParams tells whether clearing browser cookies is
// supported.
type CanClearBrowserCookiesParams struct{}

// CanClearBrowserCookies tells whether clearing browser cookies is
// supported.
func CanClearBrowserCookies() *CanClearBrowserCookiesParams {
	return &CanClearBrowserCookiesParams{}
}

// CanClearBrowserCookiesReturns return values.
type CanClearBrowserCookiesReturns struct {
	Result bool `json:"result,omitempty"` // True if browser cookies can be cleared.
}

// Do executes Network.canClearBrowserCookies against the provided context and
// target handler.
//
// returns:
//   result - True if browser cookies can be cleared.
func (p *CanClearBrowserCookiesParams) Do(ctxt context.Context, h cdp.Handler) (result bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkCanClearBrowserCookies, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CanClearBrowserCookiesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return false, cdp.ErrInvalidResult
			}

			return r.Result, nil

		case error:
			return false, v
		}

	case <-ctxt.Done():
		return false, ctxt.Err()
	}

	return false, cdp.ErrUnknownResult
}

// ClearBrowserCookiesParams clears browser cookies.
type ClearBrowserCookiesParams struct{}

// ClearBrowserCookies clears browser cookies.
func ClearBrowserCookies() *ClearBrowserCookiesParams {
	return &ClearBrowserCookiesParams{}
}

// Do executes Network.clearBrowserCookies against the provided context and
// target handler.
func (p *ClearBrowserCookiesParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkClearBrowserCookies, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// GetCookiesParams returns all browser cookies for the current URL.
// Depending on the backend support, will return detailed cookie information in
// the cookies field.
type GetCookiesParams struct {
	Urls []string `json:"urls,omitempty"` // The list of URLs for which applicable cookies will be fetched
}

// GetCookies returns all browser cookies for the current URL. Depending on
// the backend support, will return detailed cookie information in the cookies
// field.
//
// parameters:
func GetCookies() *GetCookiesParams {
	return &GetCookiesParams{}
}

// WithUrls the list of URLs for which applicable cookies will be fetched.
func (p GetCookiesParams) WithUrls(urls []string) *GetCookiesParams {
	p.Urls = urls
	return &p
}

// GetCookiesReturns return values.
type GetCookiesReturns struct {
	Cookies []*Cookie `json:"cookies,omitempty"` // Array of cookie objects.
}

// Do executes Network.getCookies against the provided context and
// target handler.
//
// returns:
//   cookies - Array of cookie objects.
func (p *GetCookiesParams) Do(ctxt context.Context, h cdp.Handler) (cookies []*Cookie, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkGetCookies, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetCookiesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Cookies, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}

// GetAllCookiesParams returns all browser cookies. Depending on the backend
// support, will return detailed cookie information in the cookies field.
type GetAllCookiesParams struct{}

// GetAllCookies returns all browser cookies. Depending on the backend
// support, will return detailed cookie information in the cookies field.
func GetAllCookies() *GetAllCookiesParams {
	return &GetAllCookiesParams{}
}

// GetAllCookiesReturns return values.
type GetAllCookiesReturns struct {
	Cookies []*Cookie `json:"cookies,omitempty"` // Array of cookie objects.
}

// Do executes Network.getAllCookies against the provided context and
// target handler.
//
// returns:
//   cookies - Array of cookie objects.
func (p *GetAllCookiesParams) Do(ctxt context.Context, h cdp.Handler) (cookies []*Cookie, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkGetAllCookies, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetAllCookiesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Cookies, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}

// DeleteCookieParams deletes browser cookie with given name, domain and
// path.
type DeleteCookieParams struct {
	CookieName string `json:"cookieName"` // Name of the cookie to remove.
	URL        string `json:"url"`        // URL to match cooke domain and path.
}

// DeleteCookie deletes browser cookie with given name, domain and path.
//
// parameters:
//   cookieName - Name of the cookie to remove.
//   url - URL to match cooke domain and path.
func DeleteCookie(cookieName string, url string) *DeleteCookieParams {
	return &DeleteCookieParams{
		CookieName: cookieName,
		URL:        url,
	}
}

// Do executes Network.deleteCookie against the provided context and
// target handler.
func (p *DeleteCookieParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkDeleteCookie, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetCookieParams sets a cookie with the given cookie data; may overwrite
// equivalent cookies if they exist.
type SetCookieParams struct {
	URL            string         `json:"url"`                      // The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie.
	Name           string         `json:"name"`                     // The name of the cookie.
	Value          string         `json:"value"`                    // The value of the cookie.
	Domain         string         `json:"domain,omitempty"`         // If omitted, the cookie becomes a host-only cookie.
	Path           string         `json:"path,omitempty"`           // Defaults to the path portion of the url parameter.
	Secure         bool           `json:"secure,omitempty"`         // Defaults ot false.
	HTTPOnly       bool           `json:"httpOnly,omitempty"`       // Defaults to false.
	SameSite       CookieSameSite `json:"sameSite,omitempty"`       // Defaults to browser default behavior.
	ExpirationDate cdp.Timestamp  `json:"expirationDate,omitempty"` // If omitted, the cookie becomes a session cookie.
}

// SetCookie sets a cookie with the given cookie data; may overwrite
// equivalent cookies if they exist.
//
// parameters:
//   url - The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie.
//   name - The name of the cookie.
//   value - The value of the cookie.
func SetCookie(url string, name string, value string) *SetCookieParams {
	return &SetCookieParams{
		URL:   url,
		Name:  name,
		Value: value,
	}
}

// WithDomain if omitted, the cookie becomes a host-only cookie.
func (p SetCookieParams) WithDomain(domain string) *SetCookieParams {
	p.Domain = domain
	return &p
}

// WithPath defaults to the path portion of the url parameter.
func (p SetCookieParams) WithPath(path string) *SetCookieParams {
	p.Path = path
	return &p
}

// WithSecure defaults ot false.
func (p SetCookieParams) WithSecure(secure bool) *SetCookieParams {
	p.Secure = secure
	return &p
}

// WithHTTPOnly defaults to false.
func (p SetCookieParams) WithHTTPOnly(httpOnly bool) *SetCookieParams {
	p.HTTPOnly = httpOnly
	return &p
}

// WithSameSite defaults to browser default behavior.
func (p SetCookieParams) WithSameSite(sameSite CookieSameSite) *SetCookieParams {
	p.SameSite = sameSite
	return &p
}

// WithExpirationDate if omitted, the cookie becomes a session cookie.
func (p SetCookieParams) WithExpirationDate(expirationDate cdp.Timestamp) *SetCookieParams {
	p.ExpirationDate = expirationDate
	return &p
}

// SetCookieReturns return values.
type SetCookieReturns struct {
	Success bool `json:"success,omitempty"` // True if successfully set cookie.
}

// Do executes Network.setCookie against the provided context and
// target handler.
//
// returns:
//   success - True if successfully set cookie.
func (p *SetCookieParams) Do(ctxt context.Context, h cdp.Handler) (success bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return false, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkSetCookie, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SetCookieReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return false, cdp.ErrInvalidResult
			}

			return r.Success, nil

		case error:
			return false, v
		}

	case <-ctxt.Done():
		return false, ctxt.Err()
	}

	return false, cdp.ErrUnknownResult
}

// CanEmulateNetworkConditionsParams tells whether emulation of network
// conditions is supported.
type CanEmulateNetworkConditionsParams struct{}

// CanEmulateNetworkConditions tells whether emulation of network conditions
// is supported.
func CanEmulateNetworkConditions() *CanEmulateNetworkConditionsParams {
	return &CanEmulateNetworkConditionsParams{}
}

// CanEmulateNetworkConditionsReturns return values.
type CanEmulateNetworkConditionsReturns struct {
	Result bool `json:"result,omitempty"` // True if emulation of network conditions is supported.
}

// Do executes Network.canEmulateNetworkConditions against the provided context and
// target handler.
//
// returns:
//   result - True if emulation of network conditions is supported.
func (p *CanEmulateNetworkConditionsParams) Do(ctxt context.Context, h cdp.Handler) (result bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkCanEmulateNetworkConditions, cdp.Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CanEmulateNetworkConditionsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return false, cdp.ErrInvalidResult
			}

			return r.Result, nil

		case error:
			return false, v
		}

	case <-ctxt.Done():
		return false, ctxt.Err()
	}

	return false, cdp.ErrUnknownResult
}

// EmulateNetworkConditionsParams activates emulation of network conditions.
type EmulateNetworkConditionsParams struct {
	Offline            bool           `json:"offline"`                  // True to emulate internet disconnection.
	Latency            float64        `json:"latency"`                  // Additional latency (ms).
	DownloadThroughput float64        `json:"downloadThroughput"`       // Maximal aggregated download throughput.
	UploadThroughput   float64        `json:"uploadThroughput"`         // Maximal aggregated upload throughput.
	ConnectionType     ConnectionType `json:"connectionType,omitempty"` // Connection type if known.
}

// EmulateNetworkConditions activates emulation of network conditions.
//
// parameters:
//   offline - True to emulate internet disconnection.
//   latency - Additional latency (ms).
//   downloadThroughput - Maximal aggregated download throughput.
//   uploadThroughput - Maximal aggregated upload throughput.
func EmulateNetworkConditions(offline bool, latency float64, downloadThroughput float64, uploadThroughput float64) *EmulateNetworkConditionsParams {
	return &EmulateNetworkConditionsParams{
		Offline:            offline,
		Latency:            latency,
		DownloadThroughput: downloadThroughput,
		UploadThroughput:   uploadThroughput,
	}
}

// WithConnectionType connection type if known.
func (p EmulateNetworkConditionsParams) WithConnectionType(connectionType ConnectionType) *EmulateNetworkConditionsParams {
	p.ConnectionType = connectionType
	return &p
}

// Do executes Network.emulateNetworkConditions against the provided context and
// target handler.
func (p *EmulateNetworkConditionsParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkEmulateNetworkConditions, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetCacheDisabledParams toggles ignoring cache for each request. If true,
// cache will not be used.
type SetCacheDisabledParams struct {
	CacheDisabled bool `json:"cacheDisabled"` // Cache disabled state.
}

// SetCacheDisabled toggles ignoring cache for each request. If true, cache
// will not be used.
//
// parameters:
//   cacheDisabled - Cache disabled state.
func SetCacheDisabled(cacheDisabled bool) *SetCacheDisabledParams {
	return &SetCacheDisabledParams{
		CacheDisabled: cacheDisabled,
	}
}

// Do executes Network.setCacheDisabled against the provided context and
// target handler.
func (p *SetCacheDisabledParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkSetCacheDisabled, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetBypassServiceWorkerParams toggles ignoring of service worker for each
// request.
type SetBypassServiceWorkerParams struct {
	Bypass bool `json:"bypass"` // Bypass service worker and load from network.
}

// SetBypassServiceWorker toggles ignoring of service worker for each
// request.
//
// parameters:
//   bypass - Bypass service worker and load from network.
func SetBypassServiceWorker(bypass bool) *SetBypassServiceWorkerParams {
	return &SetBypassServiceWorkerParams{
		Bypass: bypass,
	}
}

// Do executes Network.setBypassServiceWorker against the provided context and
// target handler.
func (p *SetBypassServiceWorkerParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkSetBypassServiceWorker, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// SetDataSizeLimitsForTestParams for testing.
type SetDataSizeLimitsForTestParams struct {
	MaxTotalSize    int64 `json:"maxTotalSize"`    // Maximum total buffer size.
	MaxResourceSize int64 `json:"maxResourceSize"` // Maximum per-resource size.
}

// SetDataSizeLimitsForTest for testing.
//
// parameters:
//   maxTotalSize - Maximum total buffer size.
//   maxResourceSize - Maximum per-resource size.
func SetDataSizeLimitsForTest(maxTotalSize int64, maxResourceSize int64) *SetDataSizeLimitsForTestParams {
	return &SetDataSizeLimitsForTestParams{
		MaxTotalSize:    maxTotalSize,
		MaxResourceSize: maxResourceSize,
	}
}

// Do executes Network.setDataSizeLimitsForTest against the provided context and
// target handler.
func (p *SetDataSizeLimitsForTestParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkSetDataSizeLimitsForTest, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// GetCertificateParams returns the DER-encoded certificate.
type GetCertificateParams struct {
	Origin string `json:"origin"` // Origin to get certificate for.
}

// GetCertificate returns the DER-encoded certificate.
//
// parameters:
//   origin - Origin to get certificate for.
func GetCertificate(origin string) *GetCertificateParams {
	return &GetCertificateParams{
		Origin: origin,
	}
}

// GetCertificateReturns return values.
type GetCertificateReturns struct {
	TableNames []string `json:"tableNames,omitempty"`
}

// Do executes Network.getCertificate against the provided context and
// target handler.
//
// returns:
//   tableNames
func (p *GetCertificateParams) Do(ctxt context.Context, h cdp.Handler) (tableNames []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandNetworkGetCertificate, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetCertificateReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.TableNames, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}
