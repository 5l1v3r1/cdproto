// Package layertree provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome LayerTree domain.
//
// Generated by the chromedp-gen command.
package layertree

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/knq/chromedp/cdp/dom"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

// EnableParams enables compositing tree inspection.
type EnableParams struct{}

// Enable enables compositing tree inspection.
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes LayerTree.enable.
func (p *EnableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeEnable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// DisableParams disables compositing tree inspection.
type DisableParams struct{}

// Disable disables compositing tree inspection.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes LayerTree.disable.
func (p *DisableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeDisable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// CompositingReasonsParams provides the reasons why the given layer was
// composited.
type CompositingReasonsParams struct {
	LayerID LayerID `json:"layerId"` // The id of the layer for which we want to get the reasons it was composited.
}

// CompositingReasons provides the reasons why the given layer was
// composited.
//
// parameters:
//   layerId - The id of the layer for which we want to get the reasons it was composited.
func CompositingReasons(layerId LayerID) *CompositingReasonsParams {
	return &CompositingReasonsParams{
		LayerID: layerId,
	}
}

// CompositingReasonsReturns return values.
type CompositingReasonsReturns struct {
	CompositingReasons []string `json:"compositingReasons,omitempty"` // A list of strings specifying reasons for the given layer to become composited.
}

// Do executes LayerTree.compositingReasons.
//
// returns:
//   compositingReasons - A list of strings specifying reasons for the given layer to become composited.
func (p *CompositingReasonsParams) Do(ctxt context.Context, h FrameHandler) (compositingReasons []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeCompositingReasons, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CompositingReasonsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.CompositingReasons, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// MakeSnapshotParams returns the layer snapshot identifier.
type MakeSnapshotParams struct {
	LayerID LayerID `json:"layerId"` // The id of the layer.
}

// MakeSnapshot returns the layer snapshot identifier.
//
// parameters:
//   layerId - The id of the layer.
func MakeSnapshot(layerId LayerID) *MakeSnapshotParams {
	return &MakeSnapshotParams{
		LayerID: layerId,
	}
}

// MakeSnapshotReturns return values.
type MakeSnapshotReturns struct {
	SnapshotID SnapshotID `json:"snapshotId,omitempty"` // The id of the layer snapshot.
}

// Do executes LayerTree.makeSnapshot.
//
// returns:
//   snapshotId - The id of the layer snapshot.
func (p *MakeSnapshotParams) Do(ctxt context.Context, h FrameHandler) (snapshotId SnapshotID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeMakeSnapshot, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r MakeSnapshotReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.SnapshotID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

// LoadSnapshotParams returns the snapshot identifier.
type LoadSnapshotParams struct {
	Tiles []*PictureTile `json:"tiles"` // An array of tiles composing the snapshot.
}

// LoadSnapshot returns the snapshot identifier.
//
// parameters:
//   tiles - An array of tiles composing the snapshot.
func LoadSnapshot(tiles []*PictureTile) *LoadSnapshotParams {
	return &LoadSnapshotParams{
		Tiles: tiles,
	}
}

// LoadSnapshotReturns return values.
type LoadSnapshotReturns struct {
	SnapshotID SnapshotID `json:"snapshotId,omitempty"` // The id of the snapshot.
}

// Do executes LayerTree.loadSnapshot.
//
// returns:
//   snapshotId - The id of the snapshot.
func (p *LoadSnapshotParams) Do(ctxt context.Context, h FrameHandler) (snapshotId SnapshotID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeLoadSnapshot, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r LoadSnapshotReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.SnapshotID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

// ReleaseSnapshotParams releases layer snapshot captured by the back-end.
type ReleaseSnapshotParams struct {
	SnapshotID SnapshotID `json:"snapshotId"` // The id of the layer snapshot.
}

// ReleaseSnapshot releases layer snapshot captured by the back-end.
//
// parameters:
//   snapshotId - The id of the layer snapshot.
func ReleaseSnapshot(snapshotId SnapshotID) *ReleaseSnapshotParams {
	return &ReleaseSnapshotParams{
		SnapshotID: snapshotId,
	}
}

// Do executes LayerTree.releaseSnapshot.
func (p *ReleaseSnapshotParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeReleaseSnapshot, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type ProfileSnapshotParams struct {
	SnapshotID     SnapshotID `json:"snapshotId"`               // The id of the layer snapshot.
	MinRepeatCount int64      `json:"minRepeatCount,omitempty"` // The maximum number of times to replay the snapshot (1, if not specified).
	MinDuration    float64    `json:"minDuration,omitempty"`    // The minimum duration (in seconds) to replay the snapshot.
	ClipRect       *dom.Rect  `json:"clipRect,omitempty"`       // The clip rectangle to apply when replaying the snapshot.
}

// parameters:
//   snapshotId - The id of the layer snapshot.
func ProfileSnapshot(snapshotId SnapshotID) *ProfileSnapshotParams {
	return &ProfileSnapshotParams{
		SnapshotID: snapshotId,
	}
}

// WithMinRepeatCount the maximum number of times to replay the snapshot (1,
// if not specified).
func (p ProfileSnapshotParams) WithMinRepeatCount(minRepeatCount int64) *ProfileSnapshotParams {
	p.MinRepeatCount = minRepeatCount
	return &p
}

// WithMinDuration the minimum duration (in seconds) to replay the snapshot.
func (p ProfileSnapshotParams) WithMinDuration(minDuration float64) *ProfileSnapshotParams {
	p.MinDuration = minDuration
	return &p
}

// WithClipRect the clip rectangle to apply when replaying the snapshot.
func (p ProfileSnapshotParams) WithClipRect(clipRect *dom.Rect) *ProfileSnapshotParams {
	p.ClipRect = clipRect
	return &p
}

// ProfileSnapshotReturns return values.
type ProfileSnapshotReturns struct {
	Timings []PaintProfile `json:"timings,omitempty"` // The array of paint profiles, one per run.
}

// Do executes LayerTree.profileSnapshot.
//
// returns:
//   timings - The array of paint profiles, one per run.
func (p *ProfileSnapshotParams) Do(ctxt context.Context, h FrameHandler) (timings []PaintProfile, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeProfileSnapshot, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r ProfileSnapshotReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Timings, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// ReplaySnapshotParams replays the layer snapshot and returns the resulting
// bitmap.
type ReplaySnapshotParams struct {
	SnapshotID SnapshotID `json:"snapshotId"`         // The id of the layer snapshot.
	FromStep   int64      `json:"fromStep,omitempty"` // The first step to replay from (replay from the very start if not specified).
	ToStep     int64      `json:"toStep,omitempty"`   // The last step to replay to (replay till the end if not specified).
	Scale      float64    `json:"scale,omitempty"`    // The scale to apply while replaying (defaults to 1).
}

// ReplaySnapshot replays the layer snapshot and returns the resulting
// bitmap.
//
// parameters:
//   snapshotId - The id of the layer snapshot.
func ReplaySnapshot(snapshotId SnapshotID) *ReplaySnapshotParams {
	return &ReplaySnapshotParams{
		SnapshotID: snapshotId,
	}
}

// WithFromStep the first step to replay from (replay from the very start if
// not specified).
func (p ReplaySnapshotParams) WithFromStep(fromStep int64) *ReplaySnapshotParams {
	p.FromStep = fromStep
	return &p
}

// WithToStep the last step to replay to (replay till the end if not
// specified).
func (p ReplaySnapshotParams) WithToStep(toStep int64) *ReplaySnapshotParams {
	p.ToStep = toStep
	return &p
}

// WithScale the scale to apply while replaying (defaults to 1).
func (p ReplaySnapshotParams) WithScale(scale float64) *ReplaySnapshotParams {
	p.Scale = scale
	return &p
}

// ReplaySnapshotReturns return values.
type ReplaySnapshotReturns struct {
	DataURL string `json:"dataURL,omitempty"` // A data: URL for resulting image.
}

// Do executes LayerTree.replaySnapshot.
//
// returns:
//   dataURL - A data: URL for resulting image.
func (p *ReplaySnapshotParams) Do(ctxt context.Context, h FrameHandler) (dataURL string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeReplaySnapshot, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r ReplaySnapshotReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.DataURL, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

// SnapshotCommandLogParams replays the layer snapshot and returns canvas
// log.
type SnapshotCommandLogParams struct {
	SnapshotID SnapshotID `json:"snapshotId"` // The id of the layer snapshot.
}

// SnapshotCommandLog replays the layer snapshot and returns canvas log.
//
// parameters:
//   snapshotId - The id of the layer snapshot.
func SnapshotCommandLog(snapshotId SnapshotID) *SnapshotCommandLogParams {
	return &SnapshotCommandLogParams{
		SnapshotID: snapshotId,
	}
}

// SnapshotCommandLogReturns return values.
type SnapshotCommandLogReturns struct {
	CommandLog []easyjson.RawMessage `json:"commandLog,omitempty"` // The array of canvas function calls.
}

// Do executes LayerTree.snapshotCommandLog.
//
// returns:
//   commandLog - The array of canvas function calls.
func (p *SnapshotCommandLogParams) Do(ctxt context.Context, h FrameHandler) (commandLog []easyjson.RawMessage, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandLayerTreeSnapshotCommandLog, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SnapshotCommandLogReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.CommandLog, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}
