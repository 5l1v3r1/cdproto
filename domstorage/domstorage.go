// Package domstorage provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome DOMStorage domain.
//
// Query and modify DOM storage.
//
// Generated by the chromedp-gen command.
package domstorage

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

// EnableParams enables storage tracking, storage events will now be
// delivered to the client.
type EnableParams struct{}

// Enable enables storage tracking, storage events will now be delivered to
// the client.
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes DOMStorage.enable.
func (p *EnableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMStorageEnable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// DisableParams disables storage tracking, prevents storage events from
// being sent to the client.
type DisableParams struct{}

// Disable disables storage tracking, prevents storage events from being sent
// to the client.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes DOMStorage.disable.
func (p *DisableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMStorageDisable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type ClearParams struct {
	StorageID *StorageID `json:"storageId"`
}

// parameters:
//   storageId
func Clear(storageId *StorageID) *ClearParams {
	return &ClearParams{
		StorageID: storageId,
	}
}

// Do executes DOMStorage.clear.
func (p *ClearParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMStorageClear, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type GetDOMStorageItemsParams struct {
	StorageID *StorageID `json:"storageId"`
}

// parameters:
//   storageId
func GetDOMStorageItems(storageId *StorageID) *GetDOMStorageItemsParams {
	return &GetDOMStorageItemsParams{
		StorageID: storageId,
	}
}

// GetDOMStorageItemsReturns return values.
type GetDOMStorageItemsReturns struct {
	Entries []Item `json:"entries,omitempty"`
}

// Do executes DOMStorage.getDOMStorageItems.
//
// returns:
//   entries
func (p *GetDOMStorageItemsParams) Do(ctxt context.Context, h FrameHandler) (entries []Item, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMStorageGetDOMStorageItems, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetDOMStorageItemsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Entries, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

type SetDOMStorageItemParams struct {
	StorageID *StorageID `json:"storageId"`
	Key       string     `json:"key"`
	Value     string     `json:"value"`
}

// parameters:
//   storageId
//   key
//   value
func SetDOMStorageItem(storageId *StorageID, key string, value string) *SetDOMStorageItemParams {
	return &SetDOMStorageItemParams{
		StorageID: storageId,
		Key:       key,
		Value:     value,
	}
}

// Do executes DOMStorage.setDOMStorageItem.
func (p *SetDOMStorageItemParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMStorageSetDOMStorageItem, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type RemoveDOMStorageItemParams struct {
	StorageID *StorageID `json:"storageId"`
	Key       string     `json:"key"`
}

// parameters:
//   storageId
//   key
func RemoveDOMStorageItem(storageId *StorageID, key string) *RemoveDOMStorageItemParams {
	return &RemoveDOMStorageItemParams{
		StorageID: storageId,
		Key:       key,
	}
}

// Do executes DOMStorage.removeDOMStorageItem.
func (p *RemoveDOMStorageItemParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandDOMStorageRemoveDOMStorageItem, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}
