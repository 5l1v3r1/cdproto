// Package cachestorage provides the Chrome Debugging Protocol
// commands, types, and events for the CacheStorage domain.
//
// Generated by the chromedp-gen command.
package cachestorage

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	cdp "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

// RequestCacheNamesParams requests cache names.
type RequestCacheNamesParams struct {
	SecurityOrigin string `json:"securityOrigin"` // Security origin.
}

// RequestCacheNames requests cache names.
//
// parameters:
//   securityOrigin - Security origin.
func RequestCacheNames(securityOrigin string) *RequestCacheNamesParams {
	return &RequestCacheNamesParams{
		SecurityOrigin: securityOrigin,
	}
}

// RequestCacheNamesReturns return values.
type RequestCacheNamesReturns struct {
	Caches []*Cache `json:"caches,omitempty"` // Caches for the security origin.
}

// Do executes CacheStorage.requestCacheNames against the provided context and
// target handler.
//
// returns:
//   caches - Caches for the security origin.
func (p *RequestCacheNamesParams) Do(ctxt context.Context, h cdp.Handler) (caches []*Cache, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandCacheStorageRequestCacheNames, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestCacheNamesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, cdp.ErrInvalidResult
			}

			return r.Caches, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ctxt.Err()
	}

	return nil, cdp.ErrUnknownResult
}

// RequestEntriesParams requests data from cache.
type RequestEntriesParams struct {
	CacheID   CacheID `json:"cacheId"`   // ID of cache to get entries from.
	SkipCount int64   `json:"skipCount"` // Number of records to skip.
	PageSize  int64   `json:"pageSize"`  // Number of records to fetch.
}

// RequestEntries requests data from cache.
//
// parameters:
//   cacheID - ID of cache to get entries from.
//   skipCount - Number of records to skip.
//   pageSize - Number of records to fetch.
func RequestEntries(cacheID CacheID, skipCount int64, pageSize int64) *RequestEntriesParams {
	return &RequestEntriesParams{
		CacheID:   cacheID,
		SkipCount: skipCount,
		PageSize:  pageSize,
	}
}

// RequestEntriesReturns return values.
type RequestEntriesReturns struct {
	CacheDataEntries []*DataEntry `json:"cacheDataEntries,omitempty"` // Array of object store data entries.
	HasMore          bool         `json:"hasMore,omitempty"`          // If true, there are more entries to fetch in the given range.
}

// Do executes CacheStorage.requestEntries against the provided context and
// target handler.
//
// returns:
//   cacheDataEntries - Array of object store data entries.
//   hasMore - If true, there are more entries to fetch in the given range.
func (p *RequestEntriesParams) Do(ctxt context.Context, h cdp.Handler) (cacheDataEntries []*DataEntry, hasMore bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, false, err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandCacheStorageRequestEntries, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, false, cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestEntriesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, false, cdp.ErrInvalidResult
			}

			return r.CacheDataEntries, r.HasMore, nil

		case error:
			return nil, false, v
		}

	case <-ctxt.Done():
		return nil, false, ctxt.Err()
	}

	return nil, false, cdp.ErrUnknownResult
}

// DeleteCacheParams deletes a cache.
type DeleteCacheParams struct {
	CacheID CacheID `json:"cacheId"` // Id of cache for deletion.
}

// DeleteCache deletes a cache.
//
// parameters:
//   cacheID - Id of cache for deletion.
func DeleteCache(cacheID CacheID) *DeleteCacheParams {
	return &DeleteCacheParams{
		CacheID: cacheID,
	}
}

// Do executes CacheStorage.deleteCache against the provided context and
// target handler.
func (p *DeleteCacheParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandCacheStorageDeleteCache, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}

// DeleteEntryParams deletes a cache entry.
type DeleteEntryParams struct {
	CacheID CacheID `json:"cacheId"` // Id of cache where the entry will be deleted.
	Request string  `json:"request"` // URL spec of the request.
}

// DeleteEntry deletes a cache entry.
//
// parameters:
//   cacheID - Id of cache where the entry will be deleted.
//   request - URL spec of the request.
func DeleteEntry(cacheID CacheID, request string) *DeleteEntryParams {
	return &DeleteEntryParams{
		CacheID: cacheID,
		Request: request,
	}
}

// Do executes CacheStorage.deleteEntry against the provided context and
// target handler.
func (p *DeleteEntryParams) Do(ctxt context.Context, h cdp.Handler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, cdp.CommandCacheStorageDeleteEntry, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return cdp.ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ctxt.Err()
	}

	return cdp.ErrUnknownResult
}
