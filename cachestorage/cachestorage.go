// Package cachestorage provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome CacheStorage domain.
//
// Generated by the chromedp-gen command.
package cachestorage

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

// RequestCacheNamesParams requests cache names.
type RequestCacheNamesParams struct {
	SecurityOrigin string `json:"securityOrigin"` // Security origin.
}

// RequestCacheNames requests cache names.
//
// parameters:
//   securityOrigin - Security origin.
func RequestCacheNames(securityOrigin string) *RequestCacheNamesParams {
	return &RequestCacheNamesParams{
		SecurityOrigin: securityOrigin,
	}
}

// RequestCacheNamesReturns return values.
type RequestCacheNamesReturns struct {
	Caches []*Cache `json:"caches,omitempty"` // Caches for the security origin.
}

// Do executes CacheStorage.requestCacheNames.
//
// returns:
//   caches - Caches for the security origin.
func (p *RequestCacheNamesParams) Do(ctxt context.Context, h FrameHandler) (caches []*Cache, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCacheStorageRequestCacheNames, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestCacheNamesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Caches, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// RequestEntriesParams requests data from cache.
type RequestEntriesParams struct {
	CacheID   CacheID `json:"cacheId"`   // ID of cache to get entries from.
	SkipCount int64   `json:"skipCount"` // Number of records to skip.
	PageSize  int64   `json:"pageSize"`  // Number of records to fetch.
}

// RequestEntries requests data from cache.
//
// parameters:
//   cacheId - ID of cache to get entries from.
//   skipCount - Number of records to skip.
//   pageSize - Number of records to fetch.
func RequestEntries(cacheId CacheID, skipCount int64, pageSize int64) *RequestEntriesParams {
	return &RequestEntriesParams{
		CacheID:   cacheId,
		SkipCount: skipCount,
		PageSize:  pageSize,
	}
}

// RequestEntriesReturns return values.
type RequestEntriesReturns struct {
	CacheDataEntries []*DataEntry `json:"cacheDataEntries,omitempty"` // Array of object store data entries.
	HasMore          bool         `json:"hasMore,omitempty"`          // If true, there are more entries to fetch in the given range.
}

// Do executes CacheStorage.requestEntries.
//
// returns:
//   cacheDataEntries - Array of object store data entries.
//   hasMore - If true, there are more entries to fetch in the given range.
func (p *RequestEntriesParams) Do(ctxt context.Context, h FrameHandler) (cacheDataEntries []*DataEntry, hasMore bool, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, false, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCacheStorageRequestEntries, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, false, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r RequestEntriesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, false, ErrInvalidResult
			}

			return r.CacheDataEntries, r.HasMore, nil

		case error:
			return nil, false, v
		}

	case <-ctxt.Done():
		return nil, false, ErrContextDone
	}

	return nil, false, ErrUnknownResult
}

// DeleteCacheParams deletes a cache.
type DeleteCacheParams struct {
	CacheID CacheID `json:"cacheId"` // Id of cache for deletion.
}

// DeleteCache deletes a cache.
//
// parameters:
//   cacheId - Id of cache for deletion.
func DeleteCache(cacheId CacheID) *DeleteCacheParams {
	return &DeleteCacheParams{
		CacheID: cacheId,
	}
}

// Do executes CacheStorage.deleteCache.
func (p *DeleteCacheParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandCacheStorageDeleteCache, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// DeleteEntryParams deletes a cache entry.
type DeleteEntryParams struct {
	CacheID CacheID `json:"cacheId"` // Id of cache where the entry will be deleted.
	Request string  `json:"request"` // URL spec of the request.
}

// DeleteEntry deletes a cache entry.
//
// parameters:
//   cacheId - Id of cache where the entry will be deleted.
//   request - URL spec of the request.
func DeleteEntry(cacheId CacheID, request string) *DeleteEntryParams {
	return &DeleteEntryParams{
		CacheID: cacheId,
		Request: request,
	}
}

// Do executes CacheStorage.deleteEntry.
func (p *DeleteEntryParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandCacheStorageDeleteEntry, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}
