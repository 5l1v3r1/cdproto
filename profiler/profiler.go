// Package profiler provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome Profiler domain.
//
// Generated by the chromedp-gen command.
package profiler

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

type EnableParams struct{}

func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes Profiler.enable.
func (p *EnableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandProfilerEnable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type DisableParams struct{}

func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes Profiler.disable.
func (p *DisableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandProfilerDisable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// SetSamplingIntervalParams changes CPU profiler sampling interval. Must be
// called before CPU profiles recording started.
type SetSamplingIntervalParams struct {
	Interval int64 `json:"interval"` // New sampling interval in microseconds.
}

// SetSamplingInterval changes CPU profiler sampling interval. Must be called
// before CPU profiles recording started.
//
// parameters:
//   interval - New sampling interval in microseconds.
func SetSamplingInterval(interval int64) *SetSamplingIntervalParams {
	return &SetSamplingIntervalParams{
		Interval: interval,
	}
}

// Do executes Profiler.setSamplingInterval.
func (p *SetSamplingIntervalParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandProfilerSetSamplingInterval, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type StartParams struct{}

func Start() *StartParams {
	return &StartParams{}
}

// Do executes Profiler.start.
func (p *StartParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandProfilerStart, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type StopParams struct{}

func Stop() *StopParams {
	return &StopParams{}
}

// StopReturns return values.
type StopReturns struct {
	Profile *Profile `json:"profile,omitempty"` // Recorded profile.
}

// Do executes Profiler.stop.
//
// returns:
//   profile - Recorded profile.
func (p *StopParams) Do(ctxt context.Context, h FrameHandler) (profile *Profile, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandProfilerStop, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r StopReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Profile, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}
