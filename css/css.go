// Package css provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome CSS domain.
//
// This domain exposes CSS read/write operations. All CSS objects
// (stylesheets, rules, and styles) have an associated id used in subsequent
// operations on the related object. Each object type has a specific id
// structure, and those are not interchangeable between objects of different
// kinds. CSS objects can be loaded using the get*ForNode() calls (which accept
// a DOM node id). A client can also discover all the existing stylesheets with
// the getAllStyleSheets() method (or keeping track of the
// styleSheetAdded/styleSheetRemoved events) and subsequently load the required
// stylesheet contents using the getStyleSheet[Text]() methods.
//
// Generated by the chromedp-gen command.
package css

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"

	. "github.com/knq/chromedp/cdp"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

// EnableParams enables the CSS agent for the given page. Clients should not
// assume that the CSS agent has been enabled until the result of this command
// is received.
type EnableParams struct{}

// Enable enables the CSS agent for the given page. Clients should not assume
// that the CSS agent has been enabled until the result of this command is
// received.
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes CSS.enable.
func (p *EnableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSEnable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// DisableParams disables the CSS agent for the given page.
type DisableParams struct{}

// Disable disables the CSS agent for the given page.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes CSS.disable.
func (p *DisableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSDisable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// GetMatchedStylesForNodeParams returns requested styles for a DOM node
// identified by nodeId.
type GetMatchedStylesForNodeParams struct {
	NodeID NodeID `json:"nodeId"`
}

// GetMatchedStylesForNode returns requested styles for a DOM node identified
// by nodeId.
//
// parameters:
//   nodeId
func GetMatchedStylesForNode(nodeId NodeID) *GetMatchedStylesForNodeParams {
	return &GetMatchedStylesForNodeParams{
		NodeID: nodeId,
	}
}

// GetMatchedStylesForNodeReturns return values.
type GetMatchedStylesForNodeReturns struct {
	InlineStyle       *Style                  `json:"inlineStyle,omitempty"`       // Inline style for the specified DOM node.
	AttributesStyle   *Style                  `json:"attributesStyle,omitempty"`   // Attribute-defined element style (e.g. resulting from "width=20 height=100%").
	MatchedCSSRules   []*RuleMatch            `json:"matchedCSSRules,omitempty"`   // CSS rules matching this node, from all applicable stylesheets.
	PseudoElements    []*PseudoElementMatches `json:"pseudoElements,omitempty"`    // Pseudo style matches for this node.
	Inherited         []*InheritedStyleEntry  `json:"inherited,omitempty"`         // A chain of inherited styles (from the immediate node parent up to the DOM tree root).
	CSSKeyframesRules []*KeyframesRule        `json:"cssKeyframesRules,omitempty"` // A list of CSS keyframed animations matching this node.
}

// Do executes CSS.getMatchedStylesForNode.
//
// returns:
//   inlineStyle - Inline style for the specified DOM node.
//   attributesStyle - Attribute-defined element style (e.g. resulting from "width=20 height=100%").
//   matchedCSSRules - CSS rules matching this node, from all applicable stylesheets.
//   pseudoElements - Pseudo style matches for this node.
//   inherited - A chain of inherited styles (from the immediate node parent up to the DOM tree root).
//   cssKeyframesRules - A list of CSS keyframed animations matching this node.
func (p *GetMatchedStylesForNodeParams) Do(ctxt context.Context, h FrameHandler) (inlineStyle *Style, attributesStyle *Style, matchedCSSRules []*RuleMatch, pseudoElements []*PseudoElementMatches, inherited []*InheritedStyleEntry, cssKeyframesRules []*KeyframesRule, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, nil, nil, nil, nil, nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetMatchedStylesForNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, nil, nil, nil, nil, nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetMatchedStylesForNodeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, nil, nil, nil, nil, nil, ErrInvalidResult
			}

			return r.InlineStyle, r.AttributesStyle, r.MatchedCSSRules, r.PseudoElements, r.Inherited, r.CSSKeyframesRules, nil

		case error:
			return nil, nil, nil, nil, nil, nil, v
		}

	case <-ctxt.Done():
		return nil, nil, nil, nil, nil, nil, ErrContextDone
	}

	return nil, nil, nil, nil, nil, nil, ErrUnknownResult
}

// GetInlineStylesForNodeParams returns the styles defined inline (explicitly
// in the "style" attribute and implicitly, using DOM attributes) for a DOM node
// identified by nodeId.
type GetInlineStylesForNodeParams struct {
	NodeID NodeID `json:"nodeId"`
}

// GetInlineStylesForNode returns the styles defined inline (explicitly in
// the "style" attribute and implicitly, using DOM attributes) for a DOM node
// identified by nodeId.
//
// parameters:
//   nodeId
func GetInlineStylesForNode(nodeId NodeID) *GetInlineStylesForNodeParams {
	return &GetInlineStylesForNodeParams{
		NodeID: nodeId,
	}
}

// GetInlineStylesForNodeReturns return values.
type GetInlineStylesForNodeReturns struct {
	InlineStyle     *Style `json:"inlineStyle,omitempty"`     // Inline style for the specified DOM node.
	AttributesStyle *Style `json:"attributesStyle,omitempty"` // Attribute-defined element style (e.g. resulting from "width=20 height=100%").
}

// Do executes CSS.getInlineStylesForNode.
//
// returns:
//   inlineStyle - Inline style for the specified DOM node.
//   attributesStyle - Attribute-defined element style (e.g. resulting from "width=20 height=100%").
func (p *GetInlineStylesForNodeParams) Do(ctxt context.Context, h FrameHandler) (inlineStyle *Style, attributesStyle *Style, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetInlineStylesForNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetInlineStylesForNodeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, nil, ErrInvalidResult
			}

			return r.InlineStyle, r.AttributesStyle, nil

		case error:
			return nil, nil, v
		}

	case <-ctxt.Done():
		return nil, nil, ErrContextDone
	}

	return nil, nil, ErrUnknownResult
}

// GetComputedStyleForNodeParams returns the computed style for a DOM node
// identified by nodeId.
type GetComputedStyleForNodeParams struct {
	NodeID NodeID `json:"nodeId"`
}

// GetComputedStyleForNode returns the computed style for a DOM node
// identified by nodeId.
//
// parameters:
//   nodeId
func GetComputedStyleForNode(nodeId NodeID) *GetComputedStyleForNodeParams {
	return &GetComputedStyleForNodeParams{
		NodeID: nodeId,
	}
}

// GetComputedStyleForNodeReturns return values.
type GetComputedStyleForNodeReturns struct {
	ComputedStyle []*ComputedProperty `json:"computedStyle,omitempty"` // Computed style for the specified DOM node.
}

// Do executes CSS.getComputedStyleForNode.
//
// returns:
//   computedStyle - Computed style for the specified DOM node.
func (p *GetComputedStyleForNodeParams) Do(ctxt context.Context, h FrameHandler) (computedStyle []*ComputedProperty, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetComputedStyleForNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetComputedStyleForNodeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.ComputedStyle, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// GetPlatformFontsForNodeParams requests information about platform fonts
// which we used to render child TextNodes in the given node.
type GetPlatformFontsForNodeParams struct {
	NodeID NodeID `json:"nodeId"`
}

// GetPlatformFontsForNode requests information about platform fonts which we
// used to render child TextNodes in the given node.
//
// parameters:
//   nodeId
func GetPlatformFontsForNode(nodeId NodeID) *GetPlatformFontsForNodeParams {
	return &GetPlatformFontsForNodeParams{
		NodeID: nodeId,
	}
}

// GetPlatformFontsForNodeReturns return values.
type GetPlatformFontsForNodeReturns struct {
	Fonts []*PlatformFontUsage `json:"fonts,omitempty"` // Usage statistics for every employed platform font.
}

// Do executes CSS.getPlatformFontsForNode.
//
// returns:
//   fonts - Usage statistics for every employed platform font.
func (p *GetPlatformFontsForNodeParams) Do(ctxt context.Context, h FrameHandler) (fonts []*PlatformFontUsage, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetPlatformFontsForNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetPlatformFontsForNodeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Fonts, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// GetStyleSheetTextParams returns the current textual content and the URL
// for a stylesheet.
type GetStyleSheetTextParams struct {
	StyleSheetID StyleSheetID `json:"styleSheetId"`
}

// GetStyleSheetText returns the current textual content and the URL for a
// stylesheet.
//
// parameters:
//   styleSheetId
func GetStyleSheetText(styleSheetId StyleSheetID) *GetStyleSheetTextParams {
	return &GetStyleSheetTextParams{
		StyleSheetID: styleSheetId,
	}
}

// GetStyleSheetTextReturns return values.
type GetStyleSheetTextReturns struct {
	Text string `json:"text,omitempty"` // The stylesheet text.
}

// Do executes CSS.getStyleSheetText.
//
// returns:
//   text - The stylesheet text.
func (p *GetStyleSheetTextParams) Do(ctxt context.Context, h FrameHandler) (text string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetStyleSheetText, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetStyleSheetTextReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.Text, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

// CollectClassNamesParams returns all class names from specified stylesheet.
type CollectClassNamesParams struct {
	StyleSheetID StyleSheetID `json:"styleSheetId"`
}

// CollectClassNames returns all class names from specified stylesheet.
//
// parameters:
//   styleSheetId
func CollectClassNames(styleSheetId StyleSheetID) *CollectClassNamesParams {
	return &CollectClassNamesParams{
		StyleSheetID: styleSheetId,
	}
}

// CollectClassNamesReturns return values.
type CollectClassNamesReturns struct {
	ClassNames []string `json:"classNames,omitempty"` // Class name list.
}

// Do executes CSS.collectClassNames.
//
// returns:
//   classNames - Class name list.
func (p *CollectClassNamesParams) Do(ctxt context.Context, h FrameHandler) (classNames []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSCollectClassNames, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CollectClassNamesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.ClassNames, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// SetStyleSheetTextParams sets the new stylesheet text.
type SetStyleSheetTextParams struct {
	StyleSheetID StyleSheetID `json:"styleSheetId"`
	Text         string       `json:"text"`
}

// SetStyleSheetText sets the new stylesheet text.
//
// parameters:
//   styleSheetId
//   text
func SetStyleSheetText(styleSheetId StyleSheetID, text string) *SetStyleSheetTextParams {
	return &SetStyleSheetTextParams{
		StyleSheetID: styleSheetId,
		Text:         text,
	}
}

// SetStyleSheetTextReturns return values.
type SetStyleSheetTextReturns struct {
	SourceMapURL string `json:"sourceMapURL,omitempty"` // URL of source map associated with script (if any).
}

// Do executes CSS.setStyleSheetText.
//
// returns:
//   sourceMapURL - URL of source map associated with script (if any).
func (p *SetStyleSheetTextParams) Do(ctxt context.Context, h FrameHandler) (sourceMapURL string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSSetStyleSheetText, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SetStyleSheetTextReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.SourceMapURL, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

// SetRuleSelectorParams modifies the rule selector.
type SetRuleSelectorParams struct {
	StyleSheetID StyleSheetID `json:"styleSheetId"`
	Range        *SourceRange `json:"range"`
	Selector     string       `json:"selector"`
}

// SetRuleSelector modifies the rule selector.
//
// parameters:
//   styleSheetId
//   range
//   selector
func SetRuleSelector(styleSheetId StyleSheetID, range_ *SourceRange, selector string) *SetRuleSelectorParams {
	return &SetRuleSelectorParams{
		StyleSheetID: styleSheetId,
		Range:        range_,
		Selector:     selector,
	}
}

// SetRuleSelectorReturns return values.
type SetRuleSelectorReturns struct {
	SelectorList *SelectorList `json:"selectorList,omitempty"` // The resulting selector list after modification.
}

// Do executes CSS.setRuleSelector.
//
// returns:
//   selectorList - The resulting selector list after modification.
func (p *SetRuleSelectorParams) Do(ctxt context.Context, h FrameHandler) (selectorList *SelectorList, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSSetRuleSelector, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SetRuleSelectorReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.SelectorList, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// SetKeyframeKeyParams modifies the keyframe rule key text.
type SetKeyframeKeyParams struct {
	StyleSheetID StyleSheetID `json:"styleSheetId"`
	Range        *SourceRange `json:"range"`
	KeyText      string       `json:"keyText"`
}

// SetKeyframeKey modifies the keyframe rule key text.
//
// parameters:
//   styleSheetId
//   range
//   keyText
func SetKeyframeKey(styleSheetId StyleSheetID, range_ *SourceRange, keyText string) *SetKeyframeKeyParams {
	return &SetKeyframeKeyParams{
		StyleSheetID: styleSheetId,
		Range:        range_,
		KeyText:      keyText,
	}
}

// SetKeyframeKeyReturns return values.
type SetKeyframeKeyReturns struct {
	KeyText *Value `json:"keyText,omitempty"` // The resulting key text after modification.
}

// Do executes CSS.setKeyframeKey.
//
// returns:
//   keyText - The resulting key text after modification.
func (p *SetKeyframeKeyParams) Do(ctxt context.Context, h FrameHandler) (keyText *Value, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSSetKeyframeKey, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SetKeyframeKeyReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.KeyText, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// SetStyleTextsParams applies specified style edits one after another in the
// given order.
type SetStyleTextsParams struct {
	Edits []*StyleDeclarationEdit `json:"edits"`
}

// SetStyleTexts applies specified style edits one after another in the given
// order.
//
// parameters:
//   edits
func SetStyleTexts(edits []*StyleDeclarationEdit) *SetStyleTextsParams {
	return &SetStyleTextsParams{
		Edits: edits,
	}
}

// SetStyleTextsReturns return values.
type SetStyleTextsReturns struct {
	Styles []*Style `json:"styles,omitempty"` // The resulting styles after modification.
}

// Do executes CSS.setStyleTexts.
//
// returns:
//   styles - The resulting styles after modification.
func (p *SetStyleTextsParams) Do(ctxt context.Context, h FrameHandler) (styles []*Style, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSSetStyleTexts, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SetStyleTextsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Styles, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// SetMediaTextParams modifies the rule selector.
type SetMediaTextParams struct {
	StyleSheetID StyleSheetID `json:"styleSheetId"`
	Range        *SourceRange `json:"range"`
	Text         string       `json:"text"`
}

// SetMediaText modifies the rule selector.
//
// parameters:
//   styleSheetId
//   range
//   text
func SetMediaText(styleSheetId StyleSheetID, range_ *SourceRange, text string) *SetMediaTextParams {
	return &SetMediaTextParams{
		StyleSheetID: styleSheetId,
		Range:        range_,
		Text:         text,
	}
}

// SetMediaTextReturns return values.
type SetMediaTextReturns struct {
	Media *Media `json:"media,omitempty"` // The resulting CSS media rule after modification.
}

// Do executes CSS.setMediaText.
//
// returns:
//   media - The resulting CSS media rule after modification.
func (p *SetMediaTextParams) Do(ctxt context.Context, h FrameHandler) (media *Media, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSSetMediaText, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SetMediaTextReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Media, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// CreateStyleSheetParams creates a new special "via-inspector" stylesheet in
// the frame with given frameId.
type CreateStyleSheetParams struct {
	FrameID FrameID `json:"frameId"` // Identifier of the frame where "via-inspector" stylesheet should be created.
}

// CreateStyleSheet creates a new special "via-inspector" stylesheet in the
// frame with given frameId.
//
// parameters:
//   frameId - Identifier of the frame where "via-inspector" stylesheet should be created.
func CreateStyleSheet(frameId FrameID) *CreateStyleSheetParams {
	return &CreateStyleSheetParams{
		FrameID: frameId,
	}
}

// CreateStyleSheetReturns return values.
type CreateStyleSheetReturns struct {
	StyleSheetID StyleSheetID `json:"styleSheetId,omitempty"` // Identifier of the created "via-inspector" stylesheet.
}

// Do executes CSS.createStyleSheet.
//
// returns:
//   styleSheetId - Identifier of the created "via-inspector" stylesheet.
func (p *CreateStyleSheetParams) Do(ctxt context.Context, h FrameHandler) (styleSheetId StyleSheetID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSCreateStyleSheet, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CreateStyleSheetReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.StyleSheetID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

// AddRuleParams inserts a new rule with the given ruleText in a stylesheet
// with given styleSheetId, at the position specified by location.
type AddRuleParams struct {
	StyleSheetID StyleSheetID `json:"styleSheetId"` // The css style sheet identifier where a new rule should be inserted.
	RuleText     string       `json:"ruleText"`     // The text of a new rule.
	Location     *SourceRange `json:"location"`     // Text position of a new rule in the target style sheet.
}

// AddRule inserts a new rule with the given ruleText in a stylesheet with
// given styleSheetId, at the position specified by location.
//
// parameters:
//   styleSheetId - The css style sheet identifier where a new rule should be inserted.
//   ruleText - The text of a new rule.
//   location - Text position of a new rule in the target style sheet.
func AddRule(styleSheetId StyleSheetID, ruleText string, location *SourceRange) *AddRuleParams {
	return &AddRuleParams{
		StyleSheetID: styleSheetId,
		RuleText:     ruleText,
		Location:     location,
	}
}

// AddRuleReturns return values.
type AddRuleReturns struct {
	Rule *Rule `json:"rule,omitempty"` // The newly created rule.
}

// Do executes CSS.addRule.
//
// returns:
//   rule - The newly created rule.
func (p *AddRuleParams) Do(ctxt context.Context, h FrameHandler) (rule *Rule, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSAddRule, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r AddRuleReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Rule, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// ForcePseudoStateParams ensures that the given node will have specified
// pseudo-classes whenever its style is computed by the browser.
type ForcePseudoStateParams struct {
	NodeID              NodeID        `json:"nodeId"`              // The element id for which to force the pseudo state.
	ForcedPseudoClasses []PseudoClass `json:"forcedPseudoClasses"` // Element pseudo classes to force when computing the element's style.
}

// ForcePseudoState ensures that the given node will have specified
// pseudo-classes whenever its style is computed by the browser.
//
// parameters:
//   nodeId - The element id for which to force the pseudo state.
//   forcedPseudoClasses - Element pseudo classes to force when computing the element's style.
func ForcePseudoState(nodeId NodeID, forcedPseudoClasses []PseudoClass) *ForcePseudoStateParams {
	return &ForcePseudoStateParams{
		NodeID:              nodeId,
		ForcedPseudoClasses: forcedPseudoClasses,
	}
}

// Do executes CSS.forcePseudoState.
func (p *ForcePseudoStateParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSForcePseudoState, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// GetMediaQueriesParams returns all media queries parsed by the rendering
// engine.
type GetMediaQueriesParams struct{}

// GetMediaQueries returns all media queries parsed by the rendering engine.
func GetMediaQueries() *GetMediaQueriesParams {
	return &GetMediaQueriesParams{}
}

// GetMediaQueriesReturns return values.
type GetMediaQueriesReturns struct {
	Medias []*Media `json:"medias,omitempty"`
}

// Do executes CSS.getMediaQueries.
//
// returns:
//   medias
func (p *GetMediaQueriesParams) Do(ctxt context.Context, h FrameHandler) (medias []*Media, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetMediaQueries, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetMediaQueriesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Medias, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// SetEffectivePropertyValueForNodeParams find a rule with the given active
// property for the given node and set the new value for this property.
type SetEffectivePropertyValueForNodeParams struct {
	NodeID       NodeID `json:"nodeId"` // The element id for which to set property.
	PropertyName string `json:"propertyName"`
	Value        string `json:"value"`
}

// SetEffectivePropertyValueForNode find a rule with the given active
// property for the given node and set the new value for this property.
//
// parameters:
//   nodeId - The element id for which to set property.
//   propertyName
//   value
func SetEffectivePropertyValueForNode(nodeId NodeID, propertyName string, value string) *SetEffectivePropertyValueForNodeParams {
	return &SetEffectivePropertyValueForNodeParams{
		NodeID:       nodeId,
		PropertyName: propertyName,
		Value:        value,
	}
}

// Do executes CSS.setEffectivePropertyValueForNode.
func (p *SetEffectivePropertyValueForNodeParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSSetEffectivePropertyValueForNode, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type GetBackgroundColorsParams struct {
	NodeID NodeID `json:"nodeId"` // Id of the node to get background colors for.
}

// parameters:
//   nodeId - Id of the node to get background colors for.
func GetBackgroundColors(nodeId NodeID) *GetBackgroundColorsParams {
	return &GetBackgroundColorsParams{
		NodeID: nodeId,
	}
}

// GetBackgroundColorsReturns return values.
type GetBackgroundColorsReturns struct {
	BackgroundColors []string `json:"backgroundColors,omitempty"` // The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored (as if the image had failed to load).
}

// Do executes CSS.getBackgroundColors.
//
// returns:
//   backgroundColors - The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored (as if the image had failed to load).
func (p *GetBackgroundColorsParams) Do(ctxt context.Context, h FrameHandler) (backgroundColors []string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetBackgroundColors, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetBackgroundColorsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.BackgroundColors, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// GetLayoutTreeAndStylesParams for the main document and any content
// documents, return the LayoutTreeNodes and a whitelisted subset of the
// computed style. It only returns pushed nodes, on way to pull all nodes is to
// call DOM.getDocument with a depth of -1.
type GetLayoutTreeAndStylesParams struct {
	ComputedStyleWhitelist []string `json:"computedStyleWhitelist"` // Whitelist of computed styles to return.
}

// GetLayoutTreeAndStyles for the main document and any content documents,
// return the LayoutTreeNodes and a whitelisted subset of the computed style. It
// only returns pushed nodes, on way to pull all nodes is to call
// DOM.getDocument with a depth of -1.
//
// parameters:
//   computedStyleWhitelist - Whitelist of computed styles to return.
func GetLayoutTreeAndStyles(computedStyleWhitelist []string) *GetLayoutTreeAndStylesParams {
	return &GetLayoutTreeAndStylesParams{
		ComputedStyleWhitelist: computedStyleWhitelist,
	}
}

// GetLayoutTreeAndStylesReturns return values.
type GetLayoutTreeAndStylesReturns struct {
	LayoutTreeNodes []*LayoutTreeNode `json:"layoutTreeNodes,omitempty"`
	ComputedStyles  []*ComputedStyle  `json:"computedStyles,omitempty"`
}

// Do executes CSS.getLayoutTreeAndStyles.
//
// returns:
//   layoutTreeNodes
//   computedStyles
func (p *GetLayoutTreeAndStylesParams) Do(ctxt context.Context, h FrameHandler) (layoutTreeNodes []*LayoutTreeNode, computedStyles []*ComputedStyle, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSGetLayoutTreeAndStyles, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetLayoutTreeAndStylesReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, nil, ErrInvalidResult
			}

			return r.LayoutTreeNodes, r.ComputedStyles, nil

		case error:
			return nil, nil, v
		}

	case <-ctxt.Done():
		return nil, nil, ErrContextDone
	}

	return nil, nil, ErrUnknownResult
}

// StartRuleUsageTrackingParams enables the selector recording.
type StartRuleUsageTrackingParams struct{}

// StartRuleUsageTracking enables the selector recording.
func StartRuleUsageTracking() *StartRuleUsageTrackingParams {
	return &StartRuleUsageTrackingParams{}
}

// Do executes CSS.startRuleUsageTracking.
func (p *StartRuleUsageTrackingParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSStartRuleUsageTracking, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// StopRuleUsageTrackingParams the list of rules with an indication of
// whether these were used.
type StopRuleUsageTrackingParams struct{}

// StopRuleUsageTracking the list of rules with an indication of whether
// these were used.
func StopRuleUsageTracking() *StopRuleUsageTrackingParams {
	return &StopRuleUsageTrackingParams{}
}

// StopRuleUsageTrackingReturns return values.
type StopRuleUsageTrackingReturns struct {
	RuleUsage []*RuleUsage `json:"ruleUsage,omitempty"`
}

// Do executes CSS.stopRuleUsageTracking.
//
// returns:
//   ruleUsage
func (p *StopRuleUsageTrackingParams) Do(ctxt context.Context, h FrameHandler) (ruleUsage []*RuleUsage, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandCSSStopRuleUsageTracking, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r StopRuleUsageTrackingReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.RuleUsage, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}
