// Package page provides the Chrome Debugging Protocol
// commands, types, and events for the Chrome Page domain.
//
// Actions and events related to the inspected page belong to the page
// domain.
//
// Generated by the chromedp-gen command.
package page

// AUTOGENERATED. DO NOT EDIT.

import (
	"context"
	"encoding/base64"

	. "github.com/knq/chromedp/cdp"
	"github.com/knq/chromedp/cdp/debugger"
	"github.com/mailru/easyjson"
)

var (
	_ BackendNode
	_ BackendNodeID
	_ ComputedProperty
	_ ErrorType
	_ Frame
	_ FrameID
	_ LoaderID
	_ Message
	_ MessageError
	_ MethodType
	_ Node
	_ NodeID
	_ NodeType
	_ PseudoType
	_ RGBA
	_ ShadowRootType
	_ Timestamp
)

// EnableParams enables page domain notifications.
type EnableParams struct{}

// Enable enables page domain notifications.
func Enable() *EnableParams {
	return &EnableParams{}
}

// Do executes Page.enable.
func (p *EnableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageEnable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// DisableParams disables page domain notifications.
type DisableParams struct{}

// Disable disables page domain notifications.
func Disable() *DisableParams {
	return &DisableParams{}
}

// Do executes Page.disable.
func (p *DisableParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageDisable, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type AddScriptToEvaluateOnLoadParams struct {
	ScriptSource string `json:"scriptSource"`
}

// parameters:
//   scriptSource
func AddScriptToEvaluateOnLoad(scriptSource string) *AddScriptToEvaluateOnLoadParams {
	return &AddScriptToEvaluateOnLoadParams{
		ScriptSource: scriptSource,
	}
}

// AddScriptToEvaluateOnLoadReturns return values.
type AddScriptToEvaluateOnLoadReturns struct {
	Identifier ScriptIdentifier `json:"identifier,omitempty"` // Identifier of the added script.
}

// Do executes Page.addScriptToEvaluateOnLoad.
//
// returns:
//   identifier - Identifier of the added script.
func (p *AddScriptToEvaluateOnLoadParams) Do(ctxt context.Context, h FrameHandler) (identifier ScriptIdentifier, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageAddScriptToEvaluateOnLoad, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r AddScriptToEvaluateOnLoadReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.Identifier, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

type RemoveScriptToEvaluateOnLoadParams struct {
	Identifier ScriptIdentifier `json:"identifier"`
}

// parameters:
//   identifier
func RemoveScriptToEvaluateOnLoad(identifier ScriptIdentifier) *RemoveScriptToEvaluateOnLoadParams {
	return &RemoveScriptToEvaluateOnLoadParams{
		Identifier: identifier,
	}
}

// Do executes Page.removeScriptToEvaluateOnLoad.
func (p *RemoveScriptToEvaluateOnLoadParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageRemoveScriptToEvaluateOnLoad, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// SetAutoAttachToCreatedPagesParams controls whether browser will open a new
// inspector window for connected pages.
type SetAutoAttachToCreatedPagesParams struct {
	AutoAttach bool `json:"autoAttach"` // If true, browser will open a new inspector window for every page created from this one.
}

// SetAutoAttachToCreatedPages controls whether browser will open a new
// inspector window for connected pages.
//
// parameters:
//   autoAttach - If true, browser will open a new inspector window for every page created from this one.
func SetAutoAttachToCreatedPages(autoAttach bool) *SetAutoAttachToCreatedPagesParams {
	return &SetAutoAttachToCreatedPagesParams{
		AutoAttach: autoAttach,
	}
}

// Do executes Page.setAutoAttachToCreatedPages.
func (p *SetAutoAttachToCreatedPagesParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageSetAutoAttachToCreatedPages, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// ReloadParams reloads given page optionally ignoring the cache.
type ReloadParams struct {
	IgnoreCache            bool   `json:"ignoreCache,omitempty"`            // If true, browser cache is ignored (as if the user pressed Shift+refresh).
	ScriptToEvaluateOnLoad string `json:"scriptToEvaluateOnLoad,omitempty"` // If set, the script will be injected into all frames of the inspected page after reload.
}

// Reload reloads given page optionally ignoring the cache.
//
// parameters:
func Reload() *ReloadParams {
	return &ReloadParams{}
}

// WithIgnoreCache if true, browser cache is ignored (as if the user pressed
// Shift+refresh).
func (p ReloadParams) WithIgnoreCache(ignoreCache bool) *ReloadParams {
	p.IgnoreCache = ignoreCache
	return &p
}

// WithScriptToEvaluateOnLoad if set, the script will be injected into all
// frames of the inspected page after reload.
func (p ReloadParams) WithScriptToEvaluateOnLoad(scriptToEvaluateOnLoad string) *ReloadParams {
	p.ScriptToEvaluateOnLoad = scriptToEvaluateOnLoad
	return &p
}

// Do executes Page.reload.
func (p *ReloadParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageReload, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// NavigateParams navigates current page to the given URL.
type NavigateParams struct {
	URL string `json:"url"` // URL to navigate the page to.
}

// Navigate navigates current page to the given URL.
//
// parameters:
//   url - URL to navigate the page to.
func Navigate(url string) *NavigateParams {
	return &NavigateParams{
		URL: url,
	}
}

// NavigateReturns return values.
type NavigateReturns struct {
	FrameID FrameID `json:"frameId,omitempty"` // Frame id that will be navigated.
}

// Do executes Page.navigate.
//
// returns:
//   frameId - Frame id that will be navigated.
func (p *NavigateParams) Do(ctxt context.Context, h FrameHandler) (frameId FrameID, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return "", err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageNavigate, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r NavigateReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", ErrInvalidResult
			}

			return r.FrameID, nil

		case error:
			return "", v
		}

	case <-ctxt.Done():
		return "", ErrContextDone
	}

	return "", ErrUnknownResult
}

// StopLoadingParams force the page stop all navigations and pending resource
// fetches.
type StopLoadingParams struct{}

// StopLoading force the page stop all navigations and pending resource
// fetches.
func StopLoading() *StopLoadingParams {
	return &StopLoadingParams{}
}

// Do executes Page.stopLoading.
func (p *StopLoadingParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageStopLoading, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// GetNavigationHistoryParams returns navigation history for the current
// page.
type GetNavigationHistoryParams struct{}

// GetNavigationHistory returns navigation history for the current page.
func GetNavigationHistory() *GetNavigationHistoryParams {
	return &GetNavigationHistoryParams{}
}

// GetNavigationHistoryReturns return values.
type GetNavigationHistoryReturns struct {
	CurrentIndex int64              `json:"currentIndex,omitempty"` // Index of the current navigation history entry.
	Entries      []*NavigationEntry `json:"entries,omitempty"`      // Array of navigation history entries.
}

// Do executes Page.getNavigationHistory.
//
// returns:
//   currentIndex - Index of the current navigation history entry.
//   entries - Array of navigation history entries.
func (p *GetNavigationHistoryParams) Do(ctxt context.Context, h FrameHandler) (currentIndex int64, entries []*NavigationEntry, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageGetNavigationHistory, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return 0, nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetNavigationHistoryReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return 0, nil, ErrInvalidResult
			}

			return r.CurrentIndex, r.Entries, nil

		case error:
			return 0, nil, v
		}

	case <-ctxt.Done():
		return 0, nil, ErrContextDone
	}

	return 0, nil, ErrUnknownResult
}

// NavigateToHistoryEntryParams navigates current page to the given history
// entry.
type NavigateToHistoryEntryParams struct {
	EntryID int64 `json:"entryId"` // Unique id of the entry to navigate to.
}

// NavigateToHistoryEntry navigates current page to the given history entry.
//
// parameters:
//   entryId - Unique id of the entry to navigate to.
func NavigateToHistoryEntry(entryId int64) *NavigateToHistoryEntryParams {
	return &NavigateToHistoryEntryParams{
		EntryID: entryId,
	}
}

// Do executes Page.navigateToHistoryEntry.
func (p *NavigateToHistoryEntryParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageNavigateToHistoryEntry, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// GetResourceTreeParams returns present frame / resource tree structure.
type GetResourceTreeParams struct{}

// GetResourceTree returns present frame / resource tree structure.
func GetResourceTree() *GetResourceTreeParams {
	return &GetResourceTreeParams{}
}

// GetResourceTreeReturns return values.
type GetResourceTreeReturns struct {
	FrameTree *FrameResourceTree `json:"frameTree,omitempty"` // Present frame / resource tree structure.
}

// Do executes Page.getResourceTree.
//
// returns:
//   frameTree - Present frame / resource tree structure.
func (p *GetResourceTreeParams) Do(ctxt context.Context, h FrameHandler) (frameTree *FrameResourceTree, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageGetResourceTree, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetResourceTreeReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.FrameTree, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// GetResourceContentParams returns content of the given resource.
type GetResourceContentParams struct {
	FrameID FrameID `json:"frameId"` // Frame id to get resource for.
	URL     string  `json:"url"`     // URL of the resource to get content for.
}

// GetResourceContent returns content of the given resource.
//
// parameters:
//   frameId - Frame id to get resource for.
//   url - URL of the resource to get content for.
func GetResourceContent(frameId FrameID, url string) *GetResourceContentParams {
	return &GetResourceContentParams{
		FrameID: frameId,
		URL:     url,
	}
}

// GetResourceContentReturns return values.
type GetResourceContentReturns struct {
	Content       string `json:"content,omitempty"`       // Resource content.
	Base64encoded bool   `json:"base64Encoded,omitempty"` // True, if content was served as base64.
}

// Do executes Page.getResourceContent.
//
// returns:
//   content - Resource content.
func (p *GetResourceContentParams) Do(ctxt context.Context, h FrameHandler) (content []byte, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageGetResourceContent, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetResourceContentReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			// decode
			var dec []byte
			if r.Base64encoded {
				dec, err = base64.StdEncoding.DecodeString(r.Content)
				if err != nil {
					return nil, err
				}
			} else {
				dec = []byte(r.Content)
			}

			return dec, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// SearchInResourceParams searches for given string in resource content.
type SearchInResourceParams struct {
	FrameID       FrameID `json:"frameId"`                 // Frame id for resource to search in.
	URL           string  `json:"url"`                     // URL of the resource to search in.
	Query         string  `json:"query"`                   // String to search for.
	CaseSensitive bool    `json:"caseSensitive,omitempty"` // If true, search is case sensitive.
	IsRegex       bool    `json:"isRegex,omitempty"`       // If true, treats string parameter as regex.
}

// SearchInResource searches for given string in resource content.
//
// parameters:
//   frameId - Frame id for resource to search in.
//   url - URL of the resource to search in.
//   query - String to search for.
func SearchInResource(frameId FrameID, url string, query string) *SearchInResourceParams {
	return &SearchInResourceParams{
		FrameID: frameId,
		URL:     url,
		Query:   query,
	}
}

// WithCaseSensitive if true, search is case sensitive.
func (p SearchInResourceParams) WithCaseSensitive(caseSensitive bool) *SearchInResourceParams {
	p.CaseSensitive = caseSensitive
	return &p
}

// WithIsRegex if true, treats string parameter as regex.
func (p SearchInResourceParams) WithIsRegex(isRegex bool) *SearchInResourceParams {
	p.IsRegex = isRegex
	return &p
}

// SearchInResourceReturns return values.
type SearchInResourceReturns struct {
	Result []*debugger.SearchMatch `json:"result,omitempty"` // List of search matches.
}

// Do executes Page.searchInResource.
//
// returns:
//   result - List of search matches.
func (p *SearchInResourceParams) Do(ctxt context.Context, h FrameHandler) (result []*debugger.SearchMatch, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return nil, err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageSearchInResource, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r SearchInResourceReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			return r.Result, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// SetDocumentContentParams sets given markup as the document's HTML.
type SetDocumentContentParams struct {
	FrameID FrameID `json:"frameId"` // Frame id to set HTML for.
	HTML    string  `json:"html"`    // HTML content to set.
}

// SetDocumentContent sets given markup as the document's HTML.
//
// parameters:
//   frameId - Frame id to set HTML for.
//   html - HTML content to set.
func SetDocumentContent(frameId FrameID, html string) *SetDocumentContentParams {
	return &SetDocumentContentParams{
		FrameID: frameId,
		HTML:    html,
	}
}

// Do executes Page.setDocumentContent.
func (p *SetDocumentContentParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageSetDocumentContent, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// CaptureScreenshotParams capture page screenshot.
type CaptureScreenshotParams struct{}

// CaptureScreenshot capture page screenshot.
func CaptureScreenshot() *CaptureScreenshotParams {
	return &CaptureScreenshotParams{}
}

// CaptureScreenshotReturns return values.
type CaptureScreenshotReturns struct {
	Data string `json:"data,omitempty"` // Base64-encoded image data (PNG).
}

// Do executes Page.captureScreenshot.
//
// returns:
//   data - Base64-encoded image data (PNG).
func (p *CaptureScreenshotParams) Do(ctxt context.Context, h FrameHandler) (data []byte, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageCaptureScreenshot, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r CaptureScreenshotReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, ErrInvalidResult
			}

			// decode
			var dec []byte
			dec, err = base64.StdEncoding.DecodeString(r.Data)
			if err != nil {
				return nil, err
			}

			return dec, nil

		case error:
			return nil, v
		}

	case <-ctxt.Done():
		return nil, ErrContextDone
	}

	return nil, ErrUnknownResult
}

// StartScreencastParams starts sending each frame using the screencastFrame
// event.
type StartScreencastParams struct {
	Format        ScreencastFormat `json:"format,omitempty"`        // Image compression format.
	Quality       int64            `json:"quality,omitempty"`       // Compression quality from range [0..100].
	MaxWidth      int64            `json:"maxWidth,omitempty"`      // Maximum screenshot width.
	MaxHeight     int64            `json:"maxHeight,omitempty"`     // Maximum screenshot height.
	EveryNthFrame int64            `json:"everyNthFrame,omitempty"` // Send every n-th frame.
}

// StartScreencast starts sending each frame using the screencastFrame event.
//
// parameters:
func StartScreencast() *StartScreencastParams {
	return &StartScreencastParams{}
}

// WithFormat image compression format.
func (p StartScreencastParams) WithFormat(format ScreencastFormat) *StartScreencastParams {
	p.Format = format
	return &p
}

// WithQuality compression quality from range [0..100].
func (p StartScreencastParams) WithQuality(quality int64) *StartScreencastParams {
	p.Quality = quality
	return &p
}

// WithMaxWidth maximum screenshot width.
func (p StartScreencastParams) WithMaxWidth(maxWidth int64) *StartScreencastParams {
	p.MaxWidth = maxWidth
	return &p
}

// WithMaxHeight maximum screenshot height.
func (p StartScreencastParams) WithMaxHeight(maxHeight int64) *StartScreencastParams {
	p.MaxHeight = maxHeight
	return &p
}

// WithEveryNthFrame send every n-th frame.
func (p StartScreencastParams) WithEveryNthFrame(everyNthFrame int64) *StartScreencastParams {
	p.EveryNthFrame = everyNthFrame
	return &p
}

// Do executes Page.startScreencast.
func (p *StartScreencastParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageStartScreencast, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// StopScreencastParams stops sending each frame in the screencastFrame.
type StopScreencastParams struct{}

// StopScreencast stops sending each frame in the screencastFrame.
func StopScreencast() *StopScreencastParams {
	return &StopScreencastParams{}
}

// Do executes Page.stopScreencast.
func (p *StopScreencastParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageStopScreencast, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// ScreencastFrameAckParams acknowledges that a screencast frame has been
// received by the frontend.
type ScreencastFrameAckParams struct {
	SessionID int64 `json:"sessionId"` // Frame number.
}

// ScreencastFrameAck acknowledges that a screencast frame has been received
// by the frontend.
//
// parameters:
//   sessionId - Frame number.
func ScreencastFrameAck(sessionId int64) *ScreencastFrameAckParams {
	return &ScreencastFrameAckParams{
		SessionID: sessionId,
	}
}

// Do executes Page.screencastFrameAck.
func (p *ScreencastFrameAckParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageScreencastFrameAck, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// HandleJavaScriptDialogParams accepts or dismisses a JavaScript initiated
// dialog (alert, confirm, prompt, or onbeforeunload).
type HandleJavaScriptDialogParams struct {
	Accept     bool   `json:"accept"`               // Whether to accept or dismiss the dialog.
	PromptText string `json:"promptText,omitempty"` // The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
}

// HandleJavaScriptDialog accepts or dismisses a JavaScript initiated dialog
// (alert, confirm, prompt, or onbeforeunload).
//
// parameters:
//   accept - Whether to accept or dismiss the dialog.
func HandleJavaScriptDialog(accept bool) *HandleJavaScriptDialogParams {
	return &HandleJavaScriptDialogParams{
		Accept: accept,
	}
}

// WithPromptText the text to enter into the dialog prompt before accepting.
// Used only if this is a prompt dialog.
func (p HandleJavaScriptDialogParams) WithPromptText(promptText string) *HandleJavaScriptDialogParams {
	p.PromptText = promptText
	return &p
}

// Do executes Page.handleJavaScriptDialog.
func (p *HandleJavaScriptDialogParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageHandleJavaScriptDialog, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// SetColorPickerEnabledParams shows / hides color picker.
type SetColorPickerEnabledParams struct {
	Enabled bool `json:"enabled"` // Shows / hides color picker
}

// SetColorPickerEnabled shows / hides color picker.
//
// parameters:
//   enabled - Shows / hides color picker
func SetColorPickerEnabled(enabled bool) *SetColorPickerEnabledParams {
	return &SetColorPickerEnabledParams{
		Enabled: enabled,
	}
}

// Do executes Page.setColorPickerEnabled.
func (p *SetColorPickerEnabledParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageSetColorPickerEnabled, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// ConfigureOverlayParams configures overlay.
type ConfigureOverlayParams struct {
	Suspended bool   `json:"suspended,omitempty"` // Whether overlay should be suspended and not consume any resources.
	Message   string `json:"message,omitempty"`   // Overlay message to display.
}

// ConfigureOverlay configures overlay.
//
// parameters:
func ConfigureOverlay() *ConfigureOverlayParams {
	return &ConfigureOverlayParams{}
}

// WithSuspended whether overlay should be suspended and not consume any
// resources.
func (p ConfigureOverlayParams) WithSuspended(suspended bool) *ConfigureOverlayParams {
	p.Suspended = suspended
	return &p
}

// WithMessage overlay message to display.
func (p ConfigureOverlayParams) WithMessage(message string) *ConfigureOverlayParams {
	p.Message = message
	return &p
}

// Do executes Page.configureOverlay.
func (p *ConfigureOverlayParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageConfigureOverlay, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

type GetAppManifestParams struct{}

func GetAppManifest() *GetAppManifestParams {
	return &GetAppManifestParams{}
}

// GetAppManifestReturns return values.
type GetAppManifestReturns struct {
	URL    string              `json:"url,omitempty"` // Manifest location.
	Errors []*AppManifestError `json:"errors,omitempty"`
	Data   string              `json:"data,omitempty"` // Manifest content.
}

// Do executes Page.getAppManifest.
//
// returns:
//   url - Manifest location.
//   errors
//   data - Manifest content.
func (p *GetAppManifestParams) Do(ctxt context.Context, h FrameHandler) (url string, errors []*AppManifestError, data string, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageGetAppManifest, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return "", nil, "", ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetAppManifestReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return "", nil, "", ErrInvalidResult
			}

			return r.URL, r.Errors, r.Data, nil

		case error:
			return "", nil, "", v
		}

	case <-ctxt.Done():
		return "", nil, "", ErrContextDone
	}

	return "", nil, "", ErrUnknownResult
}

type RequestAppBannerParams struct{}

func RequestAppBanner() *RequestAppBannerParams {
	return &RequestAppBannerParams{}
}

// Do executes Page.requestAppBanner.
func (p *RequestAppBannerParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageRequestAppBanner, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// SetControlNavigationsParams toggles navigation throttling which allows
// programatic control over navigation and redirect response.
type SetControlNavigationsParams struct {
	Enabled bool `json:"enabled"`
}

// SetControlNavigations toggles navigation throttling which allows
// programatic control over navigation and redirect response.
//
// parameters:
//   enabled
func SetControlNavigations(enabled bool) *SetControlNavigationsParams {
	return &SetControlNavigationsParams{
		Enabled: enabled,
	}
}

// Do executes Page.setControlNavigations.
func (p *SetControlNavigationsParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageSetControlNavigations, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// ProcessNavigationParams should be sent in response to a
// navigationRequested or a redirectRequested event, telling the browser how to
// handle the navigation.
type ProcessNavigationParams struct {
	Response     NavigationResponse `json:"response"`
	NavigationID int64              `json:"navigationId"`
}

// ProcessNavigation should be sent in response to a navigationRequested or a
// redirectRequested event, telling the browser how to handle the navigation.
//
// parameters:
//   response
//   navigationId
func ProcessNavigation(response NavigationResponse, navigationId int64) *ProcessNavigationParams {
	return &ProcessNavigationParams{
		Response:     response,
		NavigationID: navigationId,
	}
}

// Do executes Page.processNavigation.
func (p *ProcessNavigationParams) Do(ctxt context.Context, h FrameHandler) (err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// marshal
	buf, err := easyjson.Marshal(p)
	if err != nil {
		return err
	}

	// execute
	ch := h.Execute(ctxt, CommandPageProcessNavigation, easyjson.RawMessage(buf))

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			return nil

		case error:
			return v
		}

	case <-ctxt.Done():
		return ErrContextDone
	}

	return ErrUnknownResult
}

// GetLayoutMetricsParams returns metrics relating to the layouting of the
// page, such as viewport bounds/scale.
type GetLayoutMetricsParams struct{}

// GetLayoutMetrics returns metrics relating to the layouting of the page,
// such as viewport bounds/scale.
func GetLayoutMetrics() *GetLayoutMetricsParams {
	return &GetLayoutMetricsParams{}
}

// GetLayoutMetricsReturns return values.
type GetLayoutMetricsReturns struct {
	LayoutViewport *LayoutViewport `json:"layoutViewport,omitempty"` // Metrics relating to the layout viewport.
	VisualViewport *VisualViewport `json:"visualViewport,omitempty"` // Metrics relating to the visual viewport.
}

// Do executes Page.getLayoutMetrics.
//
// returns:
//   layoutViewport - Metrics relating to the layout viewport.
//   visualViewport - Metrics relating to the visual viewport.
func (p *GetLayoutMetricsParams) Do(ctxt context.Context, h FrameHandler) (layoutViewport *LayoutViewport, visualViewport *VisualViewport, err error) {
	if ctxt == nil {
		ctxt = context.Background()
	}

	// execute
	ch := h.Execute(ctxt, CommandPageGetLayoutMetrics, Empty)

	// read response
	select {
	case res := <-ch:
		if res == nil {
			return nil, nil, ErrChannelClosed
		}

		switch v := res.(type) {
		case easyjson.RawMessage:
			// unmarshal
			var r GetLayoutMetricsReturns
			err = easyjson.Unmarshal(v, &r)
			if err != nil {
				return nil, nil, ErrInvalidResult
			}

			return r.LayoutViewport, r.VisualViewport, nil

		case error:
			return nil, nil, v
		}

	case <-ctxt.Done():
		return nil, nil, ErrContextDone
	}

	return nil, nil, ErrUnknownResult
}
